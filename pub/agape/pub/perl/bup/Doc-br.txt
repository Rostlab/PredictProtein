# 
# -----------------------------------------------------------------------------# 
#                               ---------------------
#   br                          internal subroutines:
#                               ---------------------
# 
#   evalsecTableqils2syn        greps the final summary from TABLEQILS (xevalsec.f)
#   evalseg_oneprotein          evaluates the pred accuracy as HTM segments
#   getPhdSubset                subset from string with PHDsec|acc|htm + rel index
#   globeFuncFit                length to number of surface molecules fitted to PHD error 
#   globeFuncJoinPhdSeg         applies ad-hoc rule to join PHDglobe  and SEG
#   globeFuncJoinPhdSegIni      initialises the function used to apply the rule
#   globeOne                    1
#   globeOneIni                 interprets input arguments
#   globeOneCombi               runs SEG and combines results with PHDglobeNorm
#   globeProb                   translates normalised diff in exp res to prob
#   globeProbIni                sets the values for the probability assignment
#   globeRd_phdRdb              read PHD rdb file with ACC
#   globeWrt                    writes output for GLOBE
#   phdAliWrt                   converts PHD.rdb to SAF format (including ali)
#   phdHtmIsit                  returns best HTM
#   phdHtmGetBest               returns position (begin) and average val for best HTM
#   phdPredWrt                  writes into file readable by EVALSEC|ACC
#   phdRdbMerge                 manages merging two PHD *.rdb files ('name'= acc + sec + htm)
#   phdRdbMergeDef              sets defaults for phdRdbMerg
#   phdRdbMergeDo               merging two PHD *.rdb files ('name'= acc + sec)
#   phdRdbMergeHdr              writes the merged RDB header
#   phdRun                      runs all 3 FORTRAN programs PHD
#   phdRun1                     runs the FORTRAN program PHD once (sec XOR acc XOR htm) 
#   phdRunIniFileNames          assigns names to intermediate files for FORTRAN PHD
#   phdRunPost1                 
#   phdRunWrt                   merges 2-3 RDB files (sec,acc,htm?)
#   ppHsspRdExtrHeader          extracts the summary from HSSP header (for PP)
#   ppStripRd                   reads the new strip file generated for PP
#   ppTopitsHdWrt               writes the final PP TOPITS output file
#   ranPickFast                 selects succesion of numbers 1..$numSamLoc at 
#   ranPickGood                 selects succesion of numbers 1..$numSamLoc at 
#   rdbphd_to_dotpred           converts RDB files of PHDsec,acc,htm (both/3)
#   rdbphd_to_dotpred_getstring transform $rdb{"osec","1..n"} to $STRING{"osec"}
#   rdbphd_to_dotpred_getsubset assigns subsets:
#   rdbphd_to_dotpred_head_htmtop writes the header for htmtop
#   read_exp80                  reads a secondary structure 80lines file
#   read_sec80                  reads a secondary structure 80lines file
#   topitsWrtOwn                writes the TOPITS format
#   topitsWrtOwnHdr             writes the HEADER for the TOPITS specific format
#   wrt_dssp_phd                writes DSSP format for
#   wrt_phd_header2pp           header for phd2pp
#   wrt_phd_rdb2col             writes out the PP send format
#   wrt_phd_rdb2pp              writes out the PP send format
#   wrt_phd2msf                 converts HSSP to MSF and merges the PHD prediction
#   wrt_phdpred_from_string     write body of PHD.pred files from global array %STRING{}
#   wrt_phdpred_from_string_htm body of PHD.pred files from global array %STRING{} for HTM
#   wrt_phdpred_from_string_htm_header 
#   wrt_phdpred_from_string_htmHdr writes the header for PHDhtm ref and top
#   wrt_ppcol                   writes out the PP column format
#   wrt_strip_pp2               writes the final PP output file
#   wrtHsspHeaderTopBlabla      writes header for HSSP RDB (or simlar) output file
#   wrtHsspHeaderTopData        write DATA for new header of HSSP (or simlar)
#   wrtHsspHeaderTopFirstLine   writes first line for HSSP+STRIP header (perl-rdb)
#   wrtHsspHeaderTopLastLine    writes last line for top of header (to recognise next)
# 
# -----------------------------------------------------------------------------# 
#                               ---------------------
#   br                          external subroutines:
#                               ---------------------
# 
#   call from br:               getPhdSubset,globeFuncFit,globeFuncJoinPhdSeg,globeFuncJoinPhdSegIni
#                               globeOneCombi,globeOneIni,globeProb,globeProbIni,globeRd_phdRdb
#                               phdHtmGetBest,phdHtmIsit,phdRdbMerge,phdRdbMergeDef
#                               phdRdbMergeDo,phdRdbMergeHdr,phdRun1,phdRunIniFileNames
#                               phdRunPost1,phdRunWrt,rdbphd_to_dotpred_getstring,rdbphd_to_dotpred_getsubset
#                               rdbphd_to_dotpred_head_htmtop,topitsWrtOwnHdr,wrt_phd_header2pp
#                               wrt_phdpred_from_string,wrt_phdpred_from_string_htm
#                               wrt_phdpred_from_string_htm_header
# 
#   call from comp:             get_min
# 
#   call from file:             is_hssp,is_hssp_empty,is_rdb_acc,is_rdb_htm,is_rdb_htmref
#                               is_rdb_htmtop,is_rdb_sec,open_file,rdRdbAssociative
#                               rdRdbAssociativeNum,rd_rdb_associative,read_rdb_num2
# 
#   call from formats:          convHssp2msf,fastaWrt,msfWrt,safWrt
# 
#   call from hssp:             hsspRdAli,hsspRdHeader,hsspRdSeqSecAccOneLine,hsspRdStripAndHeader
#                               hsspRdStripHeader
# 
#   call from molbio:           segInterpret,segRun
# 
#   call from prot:             exposure_project_1digit
# 
#   call from scr:              errSbr,errSbrMsg,is_rdbf,myprt_npoints
# 
#   call from sys:              run_program,sysCpfile,sysDate,sysRunProg
# 
#   call from system:            
#                               $exePhd2Msf $arg$exePhd2Msf $arg
#                               echo '$tmpWrt' >> stat-htm-glob.tmp
#                               echo '$tmpWrt' >> stat-htm-htm.tmp
#                               echo '$tmpWrt' >> stat-htm-htm.tmpecho '$tmpWrt' >> stat-htm-glob.tmp
# 
#   call from missing:           
#                               ctime
#                               localtime
#                               phd_htmfil
#                               phd_htmref
#                               phd_htmtop
# 
# 
# -----------------------------------------------------------------------------# 
#                               ---------------------------
#   br                          description of subroutines:
#                               ---------------------------
#   --------------------------   
#   evalsecTableqils2syn        greps the final summary from TABLEQILS (xevalsec.f)
#       in:                     $fileInLoc
#       out:                    1|0,msg, $tmpWrt (sprintf)
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileInLoc
#       out:                    1|0,msg, $tmpWrt (sprintf)
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   evalseg_oneprotein          evaluates the pred accuracy as HTM segments
#   GLOBAL:
#   out:   $NOBS, $NOBSH, $NOBSL, $NPRD, $NPRDH, $NPRDL
#          $NCP, $NCPH, $NCPL, $NUP, $NOP, $NLONG
#   GLOBAL:
#   out:   $NOBS, $NOBSH, $NOBSL, $NPRD, $NPRDH, $NPRDL
#          $NCP, $NCPH, $NCPL, $NUP, $NOP, $NLONG
#   --------------------------   
#   getPhdSubset                subset from string with PHDsec|acc|htm + rel index
#       in:                     $stringPhdLoc : PHDsec|acc|htm
#       in:                     $stringRelLoc : reliability index (string of numbers [0-9])
#       in:                     $relThreshLoc : >= this -> write to 'subset' row
#       in:                     $relSymLoc    : use this symbol for 'not pred' in subset
#       out:                    1|0,msg,$subset
#       err:                    (1,'ok'), (0,'message')
#       in:                     $stringPhdLoc : PHDsec|acc|htm
#       in:                     $stringRelLoc : reliability index (string of numbers [0-9])
#       in:                     $relThreshLoc : >= this -> write to 'subset' row
#       in:                     $relSymLoc    : use this symbol for 'not pred' in subset
#       out:                    1|0,msg,$subset
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   globeFuncFit                length to number of surface molecules fitted to PHD error 
#                               out=(N ^ 1/3 - 2) ^ 3
#       in:                     len, acc-cut-off (allowed: 9, 16)
#       out:                    1,NsurfacePhdFit2
#       err:                    0,'msg'
#                               out=(N ^ 1/3 - 2) ^ 3
#       in:                     len, acc-cut-off (allowed: 9, 16)
#       out:                    1,NsurfacePhdFit2
#       err:                    0,'msg'
#   --------------------------   
#   globeFuncJoinPhdSeg         applies ad-hoc rule to join PHDglobe  and SEG
#      !   /|   |\   !          - between the vertical lines => IS  globular
#      !  / |   | \  !          - left and right of '!'      => NOT globular
#      ! /  |   |  \ !          ELSE function:
#       lo    0    hi           - everything left of lo      => NON globular
#                               - everything right of hi     => NON globular
#                               - ELSE                       => IS  globular
#                               lower cut-off   /
#                               y (SEG) = $funcLoAdd + $funcLoFac x (PHD)
#                               higher cut-off  \
#                               y (SEG) = $funcHiAdd + $funcHiFac x (PHD)
#       in:                     $fileInLoc
#       out:                    1|0,$msg,(yes_is_globular=1|no_is_not_globular=0)
#       err:                    (1,'ok'), (0,'message')
#      !   /|   |\   !          - between the vertical lines => IS  globular
#      !  / |   | \  !          - left and right of '!'      => NOT globular
#      ! /  |   |  \ !          ELSE function:
#       lo    0    hi           - everything left of lo      => NON globular
#                               - everything right of hi     => NON globular
#                               - ELSE                       => IS  globular
#                               lower cut-off   /
#                               y (SEG) = $funcLoAdd + $funcLoFac x (PHD)
#                               higher cut-off  \
#                               y (SEG) = $funcHiAdd + $funcHiFac x (PHD)
#       in:                     $fileInLoc
#       out:                    1|0,$msg,(yes_is_globular=1|no_is_not_globular=0)
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   globeFuncJoinPhdSegIni      initialises the function used to apply the rule
#                               SEE globeFuncJoinPhdSeg for explanation! 
#       out GLOBAL:             $FUNC_LO_FAC,$FUNC_LO_ADD,$FUNC_HI_FAC,$FUNC_HI_ADD,
#                               $PHD_LO_NO,$PHD_HI_NO,$PHD_LO_OK,$PHD_HI_OK
#                               SEE globeFuncJoinPhdSeg for explanation! 
#       out GLOBAL:             $FUNC_LO_FAC,$FUNC_LO_ADD,$FUNC_HI_FAC,$FUNC_HI_ADD,
#                               $PHD_LO_NO,$PHD_HI_NO,$PHD_LO_OK,$PHD_HI_OK
#   --------------------------   
#   globeOne                    1
#   globe                       compiles the globularity for a PHD file
#       in:                     file.phdRdb, $fhErrSbr, (with ACC!!)
#       in:                     options as $kwd=value
#       in:                     logicals 'doFixPar', 'doReturn' will set the 
#       in:                        respective parameters to 1
#                               kwd=(lenMin|exposed|isPred|doFixPar
#                                    fit2Ave   |fit2Sig   |fit2Add   |fit2Fac|
#                                    fit2Ave100|fit2Sig100|fit2Add100|fit2Fac100)
#       in:                     doSeg=0       to ommit running SEG
#       in:                     fileSeg=file  to keep the SEG output
#       out:                    1,'ok',$len,$nexp,$nfit,$diff,$evaluation,
#                                      $globePhdNorm,$globePhdProb,
#                                      $segRatio,$LisGlobularCombi,$evaluationCombi
#                         note: $segRatio=         -1 if SEG did not run!
#                               $LisGlobularCombi= -1 if SEG did not run!
#                               $evaluationCombi=   0 if SEG did not run!
#       err:                    0,message
#   globe                       compiles the globularity for a PHD file
#       in:                     file.phdRdb, $fhErrSbr, (with ACC!!)
#       in:                     options as $kwd=value
#       in:                     logicals 'doFixPar', 'doReturn' will set the 
#       in:                        respective parameters to 1
#                               kwd=(lenMin|exposed|isPred|doFixPar
#                                    fit2Ave   |fit2Sig   |fit2Add   |fit2Fac|
#                                    fit2Ave100|fit2Sig100|fit2Add100|fit2Fac100)
#       in:                     doSeg=0       to ommit running SEG
#       in:                     fileSeg=file  to keep the SEG output
#       out:                    1,'ok',$len,$nexp,$nfit,$diff,$evaluation,
#                                      $globePhdNorm,$globePhdProb,
#                                      $segRatio,$LisGlobularCombi,$evaluationCombi
#                         note: $segRatio=         -1 if SEG did not run!
#                               $LisGlobularCombi= -1 if SEG did not run!
#                               $evaluationCombi=   0 if SEG did not run!
#       err:                    0,message
#   --------------------------   
#   globeOneIni                 interprets input arguments
#       in:                     $fileInLoc
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileInLoc
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   globeOneCombi               runs SEG and combines results with PHDglobeNorm
#       in|out GLOBAL:          all (from globeOne)
#                               in particular: $fileInLoc,$globePhdNorm
#       out:                    1|0,msg,$segRatio,$LisGlobular,$evaluationCombi  
#       err:                    (1,'ok'), (0,'message')
#       in|out GLOBAL:          all (from globeOne)
#                               in particular: $fileInLoc,$globePhdNorm
#       out:                    1|0,msg,$segRatio,$LisGlobular,$evaluationCombi  
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   globeProb                   translates normalised diff in exp res to prob
#       in:                     $(norm = DIFF / length)
#       out:                    1|0,$msg,$prob (lookup table!)
#       err:                    (1,'ok'), (0,'message')
#       in:                     $(norm = DIFF / length)
#       out:                    1|0,$msg,$prob (lookup table!)
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   globeProbIni                sets the values for the probability assignment
#       out GLOBAL:             
#       out GLOBAL:             
#   --------------------------   
#   globeRd_phdRdb              read PHD rdb file with ACC
#       in:                     $fileInLoc,$fhErrSbr2
#       out:                    $len,$numExposed
#       err:                    0,'msg'
#       in:                     $fileInLoc,$fhErrSbr2
#       out:                    $len,$numExposed
#       err:                    0,'msg'
#   --------------------------   
#   globeWrt                    writes output for GLOBE
#       in:                     FILEHANDLE to print,$par=par1,par2,par3,%res
#       in:                     $res{"id"}          = 'id1,id2', i.e. list of names 
#       in:                     $res{"par1"}        = setting of parameter 1
#       in:                     $res{"expl","par1"} = explain meaning of parameter 1
#       in:                     $res{"$id","$kwd"}  = value for name $id
#       in:                         kwd=len|nexp|nfit|diff|interpret
#       out:                    write file
#       in:                     FILEHANDLE to print,$par=par1,par2,par3,%res
#       in:                     $res{"id"}          = 'id1,id2', i.e. list of names 
#       in:                     $res{"par1"}        = setting of parameter 1
#       in:                     $res{"expl","par1"} = explain meaning of parameter 1
#       in:                     $res{"$id","$kwd"}  = value for name $id
#       in:                         kwd=len|nexp|nfit|diff|interpret
#       out:                    write file
#   --------------------------   
#   phdAliWrt                   converts PHD.rdb to SAF format (including ali)
#       in:                     $fileInHssp  : HSSP file
#       in:                     $chainIn     : chain identifier ([0-9A-Z])
#       in:                     $fileInPhd   : PHD.rdb file
#       in:                     $fileOutLoc  : output *.msf file
#       in:                     $formOutLoc  : format of output file (msf|saf)
#       in:                     $LoptExpand  : do expand insertions in HSSP ?
#       in:                     $riSecLoc    : >= this -> write sec|htm to 'subset' row
#       in:                     $riAccLoc    : >= this -> write acc to 'subset' row
#       in:                     $riSymLoc    : use this symbol for 'not pred' in subset
#       in:                     $charPerLine : number of residues per line of output
#       in:                     $  :
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileInHssp  : HSSP file
#       in:                     $chainIn     : chain identifier ([0-9A-Z])
#       in:                     $fileInPhd   : PHD.rdb file
#       in:                     $fileOutLoc  : output *.msf file
#       in:                     $formOutLoc  : format of output file (msf|saf)
#       in:                     $LoptExpand  : do expand insertions in HSSP ?
#       in:                     $riSecLoc    : >= this -> write sec|htm to 'subset' row
#       in:                     $riAccLoc    : >= this -> write acc to 'subset' row
#       in:                     $riSymLoc    : use this symbol for 'not pred' in subset
#       in:                     $charPerLine : number of residues per line of output
#       in:                     $  :
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdHtmIsit                  returns best HTM
#       in:                     $fileInLoc        : PHD rdb file
#       in:                     $minValLoc        : average value of minimal helix (0.8)
#                                  undefined|0    -> defaults
#       in:                     $minLenLoc        : length of best helix (18)
#                                  undefined|0    -> defaults
#       in:                     $doStatLoc        : compute further statistics
#                                  undefined|0    -> defaults
#       out:                    1|0,msg,$LisMembrane (1=yes, 0=no),%tmp:
#                               $tmp{"valBest"}   : value of best HTM
#                               $tmp{"posBest"}   : first residue of best HTM
#                   if doStat:
#                               $tmp{"len"}       : length of protein
#                               $tmp{"nhtm"}      : number of membrane helices
#                               $tmp{"seqHtm"}    : sequence of all HTM (string)
#                               $tmp{"seqHtmBest"}: sequence of best HTM (string) 
#                                            (note: may be shorter than minLenLco)
#                               $tmp{"aveLenHtm"} : average length of HTM
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileInLoc        : PHD rdb file
#       in:                     $minValLoc        : average value of minimal helix (0.8)
#                                  undefined|0    -> defaults
#       in:                     $minLenLoc        : length of best helix (18)
#                                  undefined|0    -> defaults
#       in:                     $doStatLoc        : compute further statistics
#                                  undefined|0    -> defaults
#       out:                    1|0,msg,$LisMembrane (1=yes, 0=no),%tmp:
#                               $tmp{"valBest"}   : value of best HTM
#                               $tmp{"posBest"}   : first residue of best HTM
#                   if doStat:
#                               $tmp{"len"}       : length of protein
#                               $tmp{"nhtm"}      : number of membrane helices
#                               $tmp{"seqHtm"}    : sequence of all HTM (string)
#                               $tmp{"seqHtmBest"}: sequence of best HTM (string) 
#                                            (note: may be shorter than minLenLco)
#                               $tmp{"aveLenHtm"} : average length of HTM
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdHtmGetBest               returns position (begin) and average val for best HTM
#       in:                     $minValLoc        : average value of minimal helix (0.8)
#                                  = 0    -> defaults (18)
#       in:                     @tmp=             network output HTM unit (0 <= OtH <= 100)
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $minValLoc        : average value of minimal helix (0.8)
#                                  = 0    -> defaults (18)
#       in:                     @tmp=             network output HTM unit (0 <= OtH <= 100)
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdPredWrt                  writes into file readable by EVALSEC|ACC
#       in:                     $fileOutLoc:     output file name
#                  alternative: STDOUT           -> write to STDOUT
#       in:                     $idvec:          'id1,id2,..' i.e. all ids to write
#       in:                     $desvec:         'AA,OHEL,PHEL,RI_S'
#       in:                     $opt_phd:        sec|acc|htm|?
#       in:                     $nres_per_row:   number of residues per row (80!)
#       in:                     $all{} with
#                               $all{'$id','NROWS'}= number of residues of protein $id
#                               $all{'$id','$des'}=  string for $des=
#                                   sec: AA|OHEL|PHEL|RI_S
#                                   acc: AA|OHEL|OREL|PREL|RI_A
#                                   htm: AA|OHL|PHL|PFHL|PRHL|PR2HL|RI_S|H
#       out:                    1|0,msg ; implicit: file_out
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileOutLoc:     output file name
#                  alternative: STDOUT           -> write to STDOUT
#       in:                     $idvec:          'id1,id2,..' i.e. all ids to write
#       in:                     $desvec:         'AA,OHEL,PHEL,RI_S'
#       in:                     $opt_phd:        sec|acc|htm|?
#       in:                     $nres_per_row:   number of residues per row (80!)
#       in:                     $all{} with
#                               $all{'$id','NROWS'}= number of residues of protein $id
#                               $all{'$id','$des'}=  string for $des=
#                                   sec: AA|OHEL|PHEL|RI_S
#                                   acc: AA|OHEL|OREL|PREL|RI_A
#                                   htm: AA|OHL|PHL|PFHL|PRHL|PR2HL|RI_S|H
#       out:                    1|0,msg ; implicit: file_out
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdRdbMerge                 manages merging two PHD *.rdb files ('name'= acc + sec + htm)
#       in:                     $fileOutRdbLoc : name of RDB output
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     @fileRdbLoc=
#       in:                        $fileSec    : PHD rdb with sec output
#       in:                        $fileAcc    : PHD rdb with acc output
#       in:                        $fileHtm    : PHD RDB with HTM output
#       out:                    1|0,$ERROR_msg|$WARNING_MESSAGE  implicit: file
#       err:                    (1,'ok warning message'), (0,'message')
#       in:                     $fileOutRdbLoc : name of RDB output
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     @fileRdbLoc=
#       in:                        $fileSec    : PHD rdb with sec output
#       in:                        $fileAcc    : PHD rdb with acc output
#       in:                        $fileHtm    : PHD RDB with HTM output
#       out:                    1|0,$ERROR_msg|$WARNING_MESSAGE  implicit: file
#       err:                    (1,'ok warning message'), (0,'message')
#   --------------------------   
#   phdRdbMergeDef              sets defaults for phdRdbMerg
#       in/out GLOBAL:          all
#       in/out GLOBAL:          all
#   --------------------------   
#   phdRdbMergeDo               merging two PHD *.rdb files ('name'= acc + sec)
#       in GLOBAL:              @desSec,@desAcc,@headerHtm,@desHtm
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     $fhoutLoc      : file handle for RDB output file
#       in:                     @fileRdbLoc=
#       in:                        $fileSec    : PHD rdb with sec output
#       in:                        $fileAcc    : PHD rdb with acc output
#       in:                        $fileHtm    : PHD RDB with HTM output
#       out:                    1|0,$ERROR_msg|$WARNING_MESSAGE  implicit: file
#       err:                    (1,'ok warning message'), (0,'message')
#       in GLOBAL:              @desSec,@desAcc,@headerHtm,@desHtm
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     $fhoutLoc      : file handle for RDB output file
#       in:                     @fileRdbLoc=
#       in:                        $fileSec    : PHD rdb with sec output
#       in:                        $fileAcc    : PHD rdb with acc output
#       in:                        $fileHtm    : PHD RDB with HTM output
#       out:                    1|0,$ERROR_msg|$WARNING_MESSAGE  implicit: file
#       err:                    (1,'ok warning message'), (0,'message')
#   --------------------------   
#   phdRdbMergeHdr              writes the merged RDB header
#   --------------------------   
#   phdRun                      runs all 3 FORTRAN programs PHD
#            input files/modes
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainHssp     : name of chain
#       in:                     $filePara*     : name of file with phd.f network parameters
#                                                for modes sec,acc,htm
#                                   = 0          to surpress
#       in:                     $optPhd3       : mode = 3|both|sec|acc|htm  (else -> ERROR)
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#            executables
#       in:                     $exePhd        : FORTRAN executable for PHD
#       in:                     $exeHtmfilLoc  : Perl executable for HTMfil
#       in:                     $exeHtmrefLoc  : Perl executable for HTMref
#       in:                     $exeHtmtopLoc  : Perl executable for HTMtop
#            modes FORTRAN
#       in:                     $optMachLoc    : for tim
#       in:                     $optKgLoc      : for KG format
#       in:                     $useridLoc     : user name         (for PP/non-pp)
#       in:                     $optIsDecLoc   : machin is DEC     (ancient)
#            modes HTM
#       in:                     $optDoHtmfil   : 1|0 do or do NOT run
#       in:                     $optDoHtmisit  : 1|0 do or do NOT run
#       in:                     $optHtmisitMin : strength of minimal HTM (default 0.8|0.7)
#                                   = >0 && <1 , real
#       in:                     $optDoHtmref   : 1|0 do or do NOT run
#       in:                     $optDoHtmtop   : 1|0 do or do NOT run
#            output files
#       in:                     $fileOutPhdLoc : human readable file
#       in:                     $fileOutRdbLoc : RDB formatted output
#       in:                     $fileOutNotLoc : file flagging that no HTM was detected
#            PERL libraries
#       in:                     $dirLib        : directory of PERL libs
#                                   = 0          to surpress (and believe scripts will run...)
#            temporary stuff
#       in:                     $dirWork       : working dir
#       in:                     $titleTmpLoc   : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $jobidLoc      : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $LdebugLoc     : =1 -> keep temporary files, =0 -> delete them
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg,%tmpFiles(list='f1,f2,f3')  implicit: files
#       out:                    
#       out:                    $fileTmp{$kwd} : with
#                               $fileTmp{kwd}= 'kwd1,kwd2,kwd3,...'
#                               $fileTmp{$kwd}  file, e.g.:
#                               $fileTmp{"sec|acc|htm|both|3","phd|rdb"}
#                NOTE:                  tmpFiles='' if ! debug (all deleted, already)
#       err:                    (1,'ok'), (0,'message')
#            input files/modes
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainHssp     : name of chain
#       in:                     $filePara*     : name of file with phd.f network parameters
#                                                for modes sec,acc,htm
#                                   = 0          to surpress
#       in:                     $optPhd3       : mode = 3|both|sec|acc|htm  (else -> ERROR)
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#            executables
#       in:                     $exePhd        : FORTRAN executable for PHD
#       in:                     $exeHtmfilLoc  : Perl executable for HTMfil
#       in:                     $exeHtmrefLoc  : Perl executable for HTMref
#       in:                     $exeHtmtopLoc  : Perl executable for HTMtop
#            modes FORTRAN
#       in:                     $optMachLoc    : for tim
#       in:                     $optKgLoc      : for KG format
#       in:                     $useridLoc     : user name         (for PP/non-pp)
#       in:                     $optIsDecLoc   : machin is DEC     (ancient)
#            modes HTM
#       in:                     $optDoHtmfil   : 1|0 do or do NOT run
#       in:                     $optDoHtmisit  : 1|0 do or do NOT run
#       in:                     $optHtmisitMin : strength of minimal HTM (default 0.8|0.7)
#                                   = >0 && <1 , real
#       in:                     $optDoHtmref   : 1|0 do or do NOT run
#       in:                     $optDoHtmtop   : 1|0 do or do NOT run
#            output files
#       in:                     $fileOutPhdLoc : human readable file
#       in:                     $fileOutRdbLoc : RDB formatted output
#       in:                     $fileOutNotLoc : file flagging that no HTM was detected
#            PERL libraries
#       in:                     $dirLib        : directory of PERL libs
#                                   = 0          to surpress (and believe scripts will run...)
#            temporary stuff
#       in:                     $dirWork       : working dir
#       in:                     $titleTmpLoc   : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $jobidLoc      : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $LdebugLoc     : =1 -> keep temporary files, =0 -> delete them
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg,%tmpFiles(list='f1,f2,f3')  implicit: files
#       out:                    
#       out:                    $fileTmp{$kwd} : with
#                               $fileTmp{kwd}= 'kwd1,kwd2,kwd3,...'
#                               $fileTmp{$kwd}  file, e.g.:
#                               $fileTmp{"sec|acc|htm|both|3","phd|rdb"}
#                NOTE:                  tmpFiles='' if ! debug (all deleted, already)
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdRun1                     runs the FORTRAN program PHD once (sec XOR acc XOR htm) 
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainIn       : name of chain
#       in:                     $exePhd        : FORTRAN executable for PHD
#       in:                     $optPhd        : mode = sec|acc|htm  (else -> ERROR)
#       in:                     $optPara       : name of file with phd.f network parameters
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $optMachLoc    : for tim
#       in:                     $optKgLoc      : for KG format
#       in:                     $useridLoc     : user name         (for PP/non-pp)
#       in:                     $optIsDecLoc   : machin is DEC     (ancient)
#       in:                     $fileOutPhdLoc : human readable file
#       in:                     $fileOutRdbLoc : RDB formatted output
#       in:                     $dirWork       : working dir
#       in:                     $
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg, implicit: files
#       err:                    ok -> (1,"ok sbr"), err -> (0,"msg")
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainIn       : name of chain
#       in:                     $exePhd        : FORTRAN executable for PHD
#       in:                     $optPhd        : mode = sec|acc|htm  (else -> ERROR)
#       in:                     $optPara       : name of file with phd.f network parameters
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $optMachLoc    : for tim
#       in:                     $optKgLoc      : for KG format
#       in:                     $useridLoc     : user name         (for PP/non-pp)
#       in:                     $optIsDecLoc   : machin is DEC     (ancient)
#       in:                     $fileOutPhdLoc : human readable file
#       in:                     $fileOutRdbLoc : RDB formatted output
#       in:                     $dirWork       : working dir
#       in:                     $
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg, implicit: files
#       err:                    ok -> (1,"ok sbr"), err -> (0,"msg")
#   --------------------------   
#   phdRunIniFileNames          assigns names to intermediate files for FORTRAN PHD
#       in:                     $optPhdLoc     : mode = 3|both|sec|acc|htm
#       in:                     $dirWork       : working dir
#       in:                     $titleTmpLoc   : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $jobidLoc      : temporary files 'dirWork.titleTmp.jobid.extX'
#       out:                    $fileTmp{$kwd} : with
#                               $fileTmp{kwd}= 'kwd1,kwd2,kwd3,...'
#                               $fileTmp{$kwd}  file, e.g.:
#                               $fileTmp{"sec|acc|htm|both|3","phd|rdb"}
#       err:                    (1,'ok'), (0,'message')
#       in:                     $optPhdLoc     : mode = 3|both|sec|acc|htm
#       in:                     $dirWork       : working dir
#       in:                     $titleTmpLoc   : temporary files 'dirWork.titleTmp.jobid.extX'
#       in:                     $jobidLoc      : temporary files 'dirWork.titleTmp.jobid.extX'
#       out:                    $fileTmp{$kwd} : with
#                               $fileTmp{kwd}= 'kwd1,kwd2,kwd3,...'
#                               $fileTmp{$kwd}  file, e.g.:
#                               $fileTmp{"sec|acc|htm|both|3","phd|rdb"}
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdRunPost1                 
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainHssp     : name of chain
#       in:                     $fileInRdbLoc  : RDB file from PHD fortran
#       in:                     $dirLib        : directory of PERL libs
#                                   = 0          to surpress
#       in:                     $optNiceLoc    : priority 'nonice|nice|nice-n'
#       in:                     $exeHtmfilLoc  : Perl executable for HTMfil
#       in:                     $exeHtmrefLoc  : Perl executable for HTMref
#       in:                     $exeHtmtopLoc  : Perl executable for HTMtop
#       in:                     $LdoHtmfil     : 1|0 do or do NOT run
#       in:                     $LdoHtmisit    : 1|0 do or do NOT run
#       in:                     $optHtmMinVal  : strength of minimal HTM (default 0.8|0.7)
#                                   = >0 && <1 , real
#       in:                     $LdoHtmref     : 1|0 do or do NOT run
#       in:                     $LdoHtmtop     : 1|0 do or do NOT run
#       in:                     $fileOutNotLoc : file flagging that no HTM was detected
#       in:                     $fileOutRdbLoc : final RDB file
#       in:                     $fileTmpFil    : temporary file from htmfil
#       in:                     $fileTmpIsit   : temporary file from htmfil
#       in:                     $fileTmpRef    : temporary file from htmfil
#       in:                     $fileTmpTop    : temporary file from htmfil
#       in:                     $LdebugLoc     : =1 -> keep temporary files, =0 -> delete them
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $fileHssp      : HSSP file to run it on
#       in:                     $chainHssp     : name of chain
#       in:                     $fileInRdbLoc  : RDB file from PHD fortran
#       in:                     $dirLib        : directory of PERL libs
#                                   = 0          to surpress
#       in:                     $optNiceLoc    : priority 'nonice|nice|nice-n'
#       in:                     $exeHtmfilLoc  : Perl executable for HTMfil
#       in:                     $exeHtmrefLoc  : Perl executable for HTMref
#       in:                     $exeHtmtopLoc  : Perl executable for HTMtop
#       in:                     $LdoHtmfil     : 1|0 do or do NOT run
#       in:                     $LdoHtmisit    : 1|0 do or do NOT run
#       in:                     $optHtmMinVal  : strength of minimal HTM (default 0.8|0.7)
#                                   = >0 && <1 , real
#       in:                     $LdoHtmref     : 1|0 do or do NOT run
#       in:                     $LdoHtmtop     : 1|0 do or do NOT run
#       in:                     $fileOutNotLoc : file flagging that no HTM was detected
#       in:                     $fileOutRdbLoc : final RDB file
#       in:                     $fileTmpFil    : temporary file from htmfil
#       in:                     $fileTmpIsit   : temporary file from htmfil
#       in:                     $fileTmpRef    : temporary file from htmfil
#       in:                     $fileTmpTop    : temporary file from htmfil
#       in:                     $LdebugLoc     : =1 -> keep temporary files, =0 -> delete them
#       in:                     $fileOutScreen : screen dumpb of system call  if = 0: 0 -> STDOUT
#       in:                     $fhSbrErr      : error file handle
#                NOTE:              = 0          to surpress writing
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   phdRunWrt                   merges 2-3 RDB files (sec,acc,htm?)
#       in:                     $optPhd3       : mode = 3|both|sec|acc|htm  (else -> ERROR)
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     $fileTmpSec    : PHD rdb with sec output
#       in:                     $fileTmpAcc    : PHD rdb with acc output
#       in:                     $fileTmpHtm    : PHD RDB with HTM output
#                                  = 0           if mode 'both' !!
#       in:                     $fileOutPhdLoc : name of ouptput file for human readable stuff
#       in:                     $fileOutRdbLoc : name of RDB output
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $optPhd3       : mode = 3|both|sec|acc|htm  (else -> ERROR)
#       in:                     $optRdbLoc     : write RDB, or not (ancient)
#       in:                     $fileAbbrRdb   : file explaining the abbreviations in RDB file
#       in:                     $fileTmpSec    : PHD rdb with sec output
#       in:                     $fileTmpAcc    : PHD rdb with acc output
#       in:                     $fileTmpHtm    : PHD RDB with HTM output
#                                  = 0           if mode 'both' !!
#       in:                     $fileOutPhdLoc : name of ouptput file for human readable stuff
#       in:                     $fileOutRdbLoc : name of RDB output
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   ppHsspRdExtrHeader          extracts the summary from HSSP header (for PP)
#       out (GLOBAL):           $rd_hssp{} (for ppTopitsHdWrt!!!)
#       out (GLOBAL):           $rd_hssp{} (for ppTopitsHdWrt!!!)
#   --------------------------   
#   ppStripRd                   reads the new strip file generated for PP
#   --------------------------   
#   ppTopitsHdWrt               writes the final PP TOPITS output file
#       in:                     $file_in,$mixLoc,@strip
#       in:                     output file, ratio str/seq (100=only struc), 
#       in:                        content of strip file
#       out:                    file written ($file_in)
#       err:                    (0,$err) (1,'ok')
#       in:                     $file_in,$mixLoc,@strip
#       in:                     output file, ratio str/seq (100=only struc), 
#       in:                        content of strip file
#       out:                    file written ($file_in)
#       err:                    (0,$err) (1,'ok')
#   --------------------------   
#   ranPickFast                 selects succesion of numbers 1..$numSamLoc at 
#                               random (faster than ranPickGood)
#       in:                     $numPicks        = number of total picks
#       in:                     $numSamLoc       = number of samples to pick from (pool)
#       in:                     $maxNumPerSamLoc = maximal number of picks per pattern
#       in:                     $minNumPerSamLoc = minimal number of picks per pattern
#       out:                    1|0,msg,@ransuccession
#       err:                    (1,'ok'), (0,'message')
#                               random (faster than ranPickGood)
#       in:                     $numPicks        = number of total picks
#       in:                     $numSamLoc       = number of samples to pick from (pool)
#       in:                     $maxNumPerSamLoc = maximal number of picks per pattern
#       in:                     $minNumPerSamLoc = minimal number of picks per pattern
#       out:                    1|0,msg,@ransuccession
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   ranPickGood                 selects succesion of numbers 1..$numSamLoc at 
#                               random  (slower but more Gaussian than ranPickFast)
#       in:                     $numPicks        = number of total picks
#       in:                     $numSamLoc       = number of samples to pick from (pool)
#       in:                     $maxNumPerSamLoc = maximal number of picks per pattern
#       in:                     $minNumPerSamLoc = minimal number of picks per pattern
#       out:                    1|0,msg,@ransuccession
#       err:                    (1,'ok'), (0,'message')
#                               random  (slower but more Gaussian than ranPickFast)
#       in:                     $numPicks        = number of total picks
#       in:                     $numSamLoc       = number of samples to pick from (pool)
#       in:                     $maxNumPerSamLoc = maximal number of picks per pattern
#       in:                     $minNumPerSamLoc = minimal number of picks per pattern
#       out:                    1|0,msg,@ransuccession
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   rdbphd_to_dotpred           converts RDB files of PHDsec,acc,htm (both/3)
#                               to .pred files as used for PP server
#                               to .pred files as used for PP server
#   --------------------------   
#   rdbphd_to_dotpred_getstring transform $rdb{"osec","1..n"} to $STRING{"osec"}
#       in::                     file
#       in / out GLOBAL:         %STRING, %rdb,$thresh_*,
#       in::                     file
#       in / out GLOBAL:         %STRING, %rdb,$thresh_*,
#   --------------------------   
#   rdbphd_to_dotpred_getsubset assigns subsets:
#       in:                     file
#       in / out GLOBAL:        %STRING, %rdb,$thresh_*,
#       in:                     file
#       in / out GLOBAL:        %STRING, %rdb,$thresh_*,
#   --------------------------   
#   rdbphd_to_dotpred_head_htmtop writes the header for htmtop
#   --------------------------   
#   read_exp80                  reads a secondary structure 80lines file
#       in:                     $fileInLoc: input file
#                               $des_seq, *sec, *phd, *rel: 
#                               descrip for seq, obs sec str, pred sec str reliability index
#                               e.g. "AA ", "Obs", "Prd", "Rel"
#                               $Lseq/sec/phd/rel: flags =0/1 read or don't read stuff
#       out GLOBAL:             @NAME, %SEQ, %SEC, %EXP, %PHDEXP, %RELEXP (key = name)
#       in:                     $fileInLoc: input file
#                               $des_seq, *sec, *phd, *rel: 
#                               descrip for seq, obs sec str, pred sec str reliability index
#                               e.g. "AA ", "Obs", "Prd", "Rel"
#                               $Lseq/sec/phd/rel: flags =0/1 read or don't read stuff
#       out GLOBAL:             @NAME, %SEQ, %SEC, %EXP, %PHDEXP, %RELEXP (key = name)
#   --------------------------   
#   read_sec80                  reads a secondary structure 80lines file
#       in:                     $fileInLoc: input file
#                               $des_seq, *sec, *phd, *rel: 
#                               descr for seq, obs sec str, pred sec str reliability index
#                               e.g. "AA ", "Obs", "Prd", "Rel"
#                               $Lseq/sec/phd/rel: flags =0/1 read or don't read stuff
#       out GLOBAL:             @NAME, %SEQ, %SEC, %PHD, %REL (key = name)
#       in:                     $fileInLoc: input file
#                               $des_seq, *sec, *phd, *rel: 
#                               descr for seq, obs sec str, pred sec str reliability index
#                               e.g. "AA ", "Obs", "Prd", "Rel"
#                               $Lseq/sec/phd/rel: flags =0/1 read or don't read stuff
#       out GLOBAL:             @NAME, %SEQ, %SEC, %PHD, %REL (key = name)
#   --------------------------   
#   topitsWrtOwn                writes the TOPITS format
#       in:                     $fileHsspLoc,$fileStripLoc,$fileOutLoc,$mix,$fhErrSbr
#       out:                    file written ($fileOutLoc)
#       err:                    ok=(1,'ok'), err=(0,'msg')
#       in:                     $fileHsspLoc,$fileStripLoc,$fileOutLoc,$mix,$fhErrSbr
#       out:                    file written ($fileOutLoc)
#       err:                    ok=(1,'ok'), err=(0,'msg')
#   --------------------------   
#   topitsWrtOwnHdr             writes the HEADER for the TOPITS specific format
#       in:                     FHOUT,"kwd1,kwd2,kwd3",%wrtLoc
#                               $wrtLoc{"$kwd"}=result of paramter
#                               $wrtLoc{"expl$kwd"}=explanation of paramter
#       in:                     FHOUT,"kwd1,kwd2,kwd3",%wrtLoc
#                               $wrtLoc{"$kwd"}=result of paramter
#                               $wrtLoc{"expl$kwd"}=explanation of paramter
#   --------------------------   
#   wrt_dssp_phd                writes DSSP format for
#       in:                     $fhoutLoc,$id_in
#       in GLOBAL:              @NUM, @SEQ, @SEC(HE ), @ACC, @RISEC, @RIACC
#       out:                    1 if ok
#       in:                     $fhoutLoc,$id_in
#       in GLOBAL:              @NUM, @SEQ, @SEC(HE ), @ACC, @RISEC, @RIACC
#       out:                    1 if ok
#   --------------------------   
#   wrt_phd_header2pp           header for phd2pp
#       in:                     $file_out, i.e. file to write header to
#       out:                    @header
#       in:                     $file_out, i.e. file to write header to
#       out:                    @header
#   --------------------------   
#   wrt_phd_rdb2col             writes out the PP send format
#   --------------------------   
#   wrt_phd_rdb2pp              writes out the PP send format
#   --------------------------   
#   wrt_phd2msf                 converts HSSP to MSF and merges the PHD prediction
#                               into the MSF file (Pred + Ali)
#       in:                     * existing HSSP file, 
#                               * to be written temporary MSF file (hssp->MSF)
#                               * existing PHD.rdb_phd file
#                               * name of output file (id.msf_phd)
#                               * executables for converting HSSP to MSF (fortran convert_seq)
#                               * $Lexpand =1 means insertions in HSSP will be filled in
#                               * perl hack to convert id.rdb_phd + id.msf to id.msf_phd
#                               * reliability index to choose SUBSET for secondary structure
#                                 prediction (taken: > riSecLoc)
#                               * reliability index for SUBacc
#                               * character used to mark regions with ri <= riSecLoc
#                               * number of characters per line of MSF file
#       out:                    writes file and reports status (0,$text), or (1," ")
#                               into the MSF file (Pred + Ali)
#       in:                     * existing HSSP file, 
#                               * to be written temporary MSF file (hssp->MSF)
#                               * existing PHD.rdb_phd file
#                               * name of output file (id.msf_phd)
#                               * executables for converting HSSP to MSF (fortran convert_seq)
#                               * $Lexpand =1 means insertions in HSSP will be filled in
#                               * perl hack to convert id.rdb_phd + id.msf to id.msf_phd
#                               * reliability index to choose SUBSET for secondary structure
#                                 prediction (taken: > riSecLoc)
#                               * reliability index for SUBacc
#                               * character used to mark regions with ri <= riSecLoc
#                               * number of characters per line of MSF file
#       out:                    writes file and reports status (0,$text), or (1," ")
#   --------------------------   
#   wrt_phdpred_from_string     write body of PHD.pred files from global array %STRING{}
#       in (GLOBAL)             %STRING, i.e., one line string with prediction,
#                               e.g., $STRING{"osec"} observed secondary structure
#       in (GLOBAL)             %STRING, i.e., one line string with prediction,
#                               e.g., $STRING{"osec"} observed secondary structure
#   --------------------------   
#   wrt_phdpred_from_string_htm body of PHD.pred files from global array %STRING{} for HTM
#       in (GLOBAL)             %STRING, i.e., one line string with prediction,
#                               e.g., $STRING{"osec"} observed secondary structure
#       in (GLOBAL)             %STRING, i.e., one line string with prediction,
#                               e.g., $STRING{"osec"} observed secondary structure
#   --------------------------   
#   wrt_phdpred_from_string_htm_header 
#   --------------------------   
#   wrt_phdpred_from_string_htmHdr writes the header for PHDhtm ref and top
#       in: header with (x1:x2), where x1 is the key and x2 the result
#       in: header with (x1:x2), where x1 is the key and x2 the result
#   --------------------------   
#   wrt_ppcol                   writes out the PP column format
#       in:                     $fhoutLoc,%rd
#       out:                    1 or 0
#       in:                     $fhoutLoc,%rd
#       out:                    1 or 0
#   --------------------------   
#   wrt_strip_pp2               writes the final PP output file
#   --------------------------   
#   wrtHsspHeaderTopBlabla      writes header for HSSP RDB (or simlar) output file
#       in:                     $fhoutLoc,$preLoc,$txtMode,$Lzscore,$Lenergy,$Lifir
#         $fhErrSbr             FILE-HANDLE to report errors
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
#         $Lzscore              write zscore description
#         $Lenergy              write energy description
#         $Lifir                write ifir,ilas,jfir,jlas description
#       in:                     $fhoutLoc,$preLoc,$txtMode,$Lzscore,$Lenergy,$Lifir
#         $fhErrSbr             FILE-HANDLE to report errors
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
#         $Lzscore              write zscore description
#         $Lenergy              write energy description
#         $Lifir                write ifir,ilas,jfir,jlas description
#   --------------------------   
#   wrtHsspHeaderTopData        write DATA for new header of HSSP (or simlar)
#       in:                     $fhoutLoc,$prexLoc,$txtMode,@data:List:($kwd,$val)
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
#       in:                     $fhoutLoc,$prexLoc,$txtMode,@data:List:($kwd,$val)
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
#   --------------------------   
#   wrtHsspHeaderTopFirstLine   writes first line for HSSP+STRIP header (perl-rdb)
#       in:                     $fhoutLoc,$txtMode
#         $fhoutLoc             file handle print output
#         $txtMode = 'RDB'      write RDB file, note: by default #
#       in:                     $fhoutLoc,$txtMode
#         $fhoutLoc             file handle print output
#         $txtMode = 'RDB'      write RDB file, note: by default #
#   --------------------------   
#   wrtHsspHeaderTopLastLine    writes last line for top of header (to recognise next)
#       in:                     $fhoutLoc,$preLoc,$txtMode
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
#       in:                     $fhoutLoc,$preLoc,$txtMode
#         $fhoutLoc             file handle print output
#         $preLoc               first letters to write
#         $txtMode = 'RDB'      write RDB file, note: by default #
