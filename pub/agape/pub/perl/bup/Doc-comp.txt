# 
# -----------------------------------------------------------------------------# 
#                               ---------------------
#   comp                        internal subroutines:
#                               ---------------------
# 
#   bynumber                    function sorting list by number
#   bynumber_high2low           function sorting list by number (start with high)
#   correlation                 between x and y
#   equal_tolerance             returns 0, if v1==v2 +- $tol
#   fRound                      returns the rounded integer of real input (7.6->8; 7.4->7)
#   func_absolute               compiles the absolute value
#   func_faculty                compiles the faculty
#   func_n_over_k               compiles N over K
#   func_n_over_k_sum           compiles sum/i {N over i}
#   func_permut_mod             computes all possible permutations for $num, e.g. n=4:
#   func_permut_mod_iterate     repeats permutations (called by func_permut_mod)
#   funcInfoConditional         Fano information
#   funcLog                     converts the perl log (base e) to any log
#   funcNormMinMax              normalises numbers with (min1,max1) to a range of (min0,max0)
#   get_max                     returns the maximum of all elements of @in
#   get_min                     returns the minimum of all elements of @in
#   get_sum                     computes the sum over input data
#   get_zscore                  returns the zscore = (score-ave)/sigma
#   is_odd_number               checks whether number is odd
#   numerically                 function sorting list by number
#   stat_avevar                 computes average and variance
#   stat2DarrayWrt              writes counts
# 
# -----------------------------------------------------------------------------# 
#                               ---------------------
#   comp                        external subroutines:
#                               ---------------------
# 
#   call from comp:             funcInfoConditional,func_absolute,func_faculty,func_n_over_k
#                               func_permut_mod_iterate,stat_avevar
# 
#   call from scr:              errSbr,errSbrMsg
# 
#   call from system:            
# 
#   call from missing:           
# 
# 
# -----------------------------------------------------------------------------# 
#                               ---------------------------
#   comp                        description of subroutines:
#                               ---------------------------
#   --------------------------   
#   bynumber                    function sorting list by number
#   --------------------------   
#   bynumber_high2low           function sorting list by number (start with high)
#   --------------------------   
#   correlation                 between x and y
#       in:                     ncol,@data, where $data[1..ncol] =@x, rest @y
#       out:                    returned $COR=correlation
#       out GLOBAL:             COR, AVE, VAR
#       in:                     ncol,@data, where $data[1..ncol] =@x, rest @y
#       out:                    returned $COR=correlation
#       out GLOBAL:             COR, AVE, VAR
#   --------------------------   
#   equal_tolerance             returns 0, if v1==v2 +- $tol
#   --------------------------   
#   fRound                      returns the rounded integer of real input (7.6->8; 7.4->7)
#       in:                     $num
#       out:                    returned |$num|
#       in:                     $num
#       out:                    returned |$num|
#   --------------------------   
#   func_absolute               compiles the absolute value
#       in:                     $num
#       out:                    returned |$num|
#       in:                     $num
#       out:                    returned |$num|
#   --------------------------   
#   func_faculty                compiles the faculty
#       in:                     $num
#       out:                    returned $fac
#       in:                     $num
#       out:                    returned $fac
#   --------------------------   
#   func_n_over_k               compiles N over K
#       in:                     $n,$k
#       out:                    returned $res
#       in:                     $n,$k
#       out:                    returned $res
#   --------------------------   
#   func_n_over_k_sum           compiles sum/i {N over i}
#       in:                     $n,$k
#       out:                    returned $res
#       in:                     $n,$k
#       out:                    returned $res
#   --------------------------   
#   func_permut_mod             computes all possible permutations for $num, e.g. n=4:
#                               output is : '1,2' '1,3' '1,4' '2,3' asf.
#       in:                     $num
#       out:                    @permutations (as text:'n,m,..')
#                               output is : '1,2' '1,3' '1,4' '2,3' asf.
#       in:                     $num
#       out:                    @permutations (as text:'n,m,..')
#   --------------------------   
#   func_permut_mod_iterate     repeats permutations (called by func_permut_mod)
#                               computes all possible permutations for $num 
#                               (e.g. =4) as maximum, and
#       input is :              '1,2' '1,3' '1,4' '2,3' asf.
#                               computes all possible permutations for $num 
#                               (e.g. =4) as maximum, and
#       input is :              '1,2' '1,3' '1,4' '2,3' asf.
#   --------------------------   
#   funcInfoConditional         Fano information
#                               R. Fano, Transmission of information, Wiley, New York, 1961
#                               S= state
#                               R= residue (feature)
#                               f= counts
#                               N= total number of residues, counts
#                               I (S;R) = log [ ( f(S,R) / f(R) ) / (f(S) / N) ]
#                               information difference:
#                               B. Robson, Biochem J., 141, 853 (1974)
#                               I (DelS;R)=I(S;R)-I(!S;R)=
#                                          log [ f(S,R)/f(!S,R) ] + log [ f(!S)/f(S) ]
#				Bayes
#				                P(S) * P(R|S)
#				P(S|R) =  -------------------------
#				          SUM/j { P(Sj) * P(R|Sj) }
#				P(S|R) = probability for state S, given res R
#       in:                     $Lfano=  1|0:    compile fano info
#       in:                     $Lrobson=1|0:    compile robsons info diff
#       in:                     $Lbayes= 1|0:    compile bayes prob
#       in:                     $tmp{}:
#                               $tmp{"S"}=       "s1,s2,.."
#                               $tmp{"R"}=       "r1,r2,.."
#                               $tmp{"$R","$S"}= count of the number of residues $res in state $S
#       out:                    1|0,msg,  $res{}
#                               $res{"Rsum","$r"}=              sum for res $r
#                               $res{"Ssum","$s"}=              sum for state $s
#                               $res{"sum"}=                    total sum
#                               $res{"fano","$r","$s"}=         Fano information
#                               $res{"robson","$r","$s"}=       Robson information difference
#                               $res{"bayes","$r","$s"}=        Bayes prob (S|R, i.e. given R->S)
#                               $res{"bayes","Rsum","$r"}=      Bayes sum over all states for res $r
#       err:                    (1,'ok'), (0,'message')
#                               R. Fano, Transmission of information, Wiley, New York, 1961
#                               S= state
#                               R= residue (feature)
#                               f= counts
#                               N= total number of residues, counts
#                               I (S;R) = log [ ( f(S,R) / f(R) ) / (f(S) / N) ]
#                               information difference:
#                               B. Robson, Biochem J., 141, 853 (1974)
#                               I (DelS;R)=I(S;R)-I(!S;R)=
#                                          log [ f(S,R)/f(!S,R) ] + log [ f(!S)/f(S) ]
#				Bayes
#				                P(S) * P(R|S)
#				P(S|R) =  -------------------------
#				          SUM/j { P(Sj) * P(R|Sj) }
#				P(S|R) = probability for state S, given res R
#       in:                     $Lfano=  1|0:    compile fano info
#       in:                     $Lrobson=1|0:    compile robsons info diff
#       in:                     $Lbayes= 1|0:    compile bayes prob
#       in:                     $tmp{}:
#                               $tmp{"S"}=       "s1,s2,.."
#                               $tmp{"R"}=       "r1,r2,.."
#                               $tmp{"$R","$S"}= count of the number of residues $res in state $S
#       out:                    1|0,msg,  $res{}
#                               $res{"Rsum","$r"}=              sum for res $r
#                               $res{"Ssum","$s"}=              sum for state $s
#                               $res{"sum"}=                    total sum
#                               $res{"fano","$r","$s"}=         Fano information
#                               $res{"robson","$r","$s"}=       Robson information difference
#                               $res{"bayes","$r","$s"}=        Bayes prob (S|R, i.e. given R->S)
#                               $res{"bayes","Rsum","$r"}=      Bayes sum over all states for res $r
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   funcLog                     converts the perl log (base e) to any log
#       in:                     $num,$base
#       out:                    log($num)/log($base)
#       in:                     $num,$base
#       out:                    log($num)/log($base)
#   --------------------------   
#   funcNormMinMax              normalises numbers with (min1,max1) to a range of (min0,max0)
#                               N(new) = N(now) * S + ( Min(want) - Min(now) * S )
#                               with S:
#                                         Max(want) - Min(want)
#                               S      =  ---------------------
#                                         Max(now)  - Min(now)
#       in:                     $numLoc,$minNow,$maxNow,$minWant,$maxWant
#       out:                    1|0,msg,$numNew
#       err:                    (1,'ok'), (0,'message')
#                               N(new) = N(now) * S + ( Min(want) - Min(now) * S )
#                               with S:
#                                         Max(want) - Min(want)
#                               S      =  ---------------------
#                                         Max(now)  - Min(now)
#       in:                     $numLoc,$minNow,$maxNow,$minWant,$maxWant
#       out:                    1|0,msg,$numNew
#       err:                    (1,'ok'), (0,'message')
#   --------------------------   
#   get_max                     returns the maximum of all elements of @in
#       in:                     @in
#       out:                    returned $max,$pos (position of maximum)
#       in:                     @in
#       out:                    returned $max,$pos (position of maximum)
#   --------------------------   
#   get_min                     returns the minimum of all elements of @in
#       in:                     @in
#       out:                    returned $min,$pos (position of minimum)
#       in:                     @in
#       out:                    returned $min,$pos (position of minimum)
#   --------------------------   
#   get_sum                     computes the sum over input data
#       in:                     @data
#       out:                    $sum,$ave,$var
#       in:                     @data
#       out:                    $sum,$ave,$var
#   --------------------------   
#   get_zscore                  returns the zscore = (score-ave)/sigma
#       in:                     $score,@data
#       out:                    zscore
#       in:                     $score,@data
#       out:                    zscore
#   --------------------------   
#   is_odd_number               checks whether number is odd
#       in:                     number
#       out:                    returns 1 if is odd, 0 else
#       in:                     number
#       out:                    returns 1 if is odd, 0 else
#   --------------------------   
#   numerically                 function sorting list by number
#   --------------------------   
#   stat_avevar                 computes average and variance
#       in:                     @data (vector)
#       out:                    $AVE, $VAR
#          GLOBAL:              $AVE, $VAR (returned as list)
#       in:                     @data (vector)
#       out:                    $AVE, $VAR
#          GLOBAL:              $AVE, $VAR (returned as list)
#   --------------------------   
#   stat2DarrayWrt              writes counts
#       in:                     $sep        :    symbol for separating columns
#       in:                     $Lnum=   1|0:    write simple counts
#       in:                     $Lperc=  1|0:    write percentages (of total sum)
#       in:                     $Lcperc= 1|0:    write row percentages (of sum over rows)
#       in:                     $Lfano=  1|0:    write fano info
#       in:                     $Lrobson=1|0:    write robsons info diff
#       in:                     $Lbayes= 1|0:    write bayes prob
#       in:                     $tmp{}:
#                               $tmp{"S"}=       "s1,s2,.."
#                               $tmp{"R"}=       "r1,r2,.."
#                               $tmp{"$R","$S"}= number of residues $res in state $S
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
#       in:                     $sep        :    symbol for separating columns
#       in:                     $Lnum=   1|0:    write simple counts
#       in:                     $Lperc=  1|0:    write percentages (of total sum)
#       in:                     $Lcperc= 1|0:    write row percentages (of sum over rows)
#       in:                     $Lfano=  1|0:    write fano info
#       in:                     $Lrobson=1|0:    write robsons info diff
#       in:                     $Lbayes= 1|0:    write bayes prob
#       in:                     $tmp{}:
#                               $tmp{"S"}=       "s1,s2,.."
#                               $tmp{"R"}=       "r1,r2,.."
#                               $tmp{"$R","$S"}= number of residues $res in state $S
#       out:                    1|0,msg,  implicit:
#       err:                    (1,'ok'), (0,'message')
