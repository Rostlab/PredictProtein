#!/usr/bin/perl -w
##!/usr/sbin/perl -w
#
$scrName=$0;$scrName=~s/^.*\/|\.pl//g;
$scrGoal="reads list of HSSP files and writes HTML table\n";
#  
#
$[ =1 ;
				# ------------------------------
				# defaults
$par{"organism"}=      "yeast";	# used for title of WWW page
$par{"nperLine"}=      50;	# number of residues per line (HTML sequence)

				# ------------------------------
if ($#ARGV<1){			# help
    print "goal:\t $scrGoal\n";
    print "use: \t '$scrName file-list'\n";
    print "opt: \t title=x      (output x.rdb x.html)\n";
    print "     \t fileOutRdb=x\n";
    print "     \t fileOutHtml=x\n";
    print "     \t noNali       (dont write NALI column)\n";
    print "     \t noSeq        (dont write Sequence column)\n";
    print "     \t nperLine=",   $par{"nperLine"},   "      (default for WWW file seq)\n";
    print "     \t organism=",   $par{"organism"},   "      (default for WWW file title)\n";
#    print "     \t \n";
    exit;}
				# initialise variables
$fhin="FHIN";$fhout="FHOUT";
				# ------------------------------
				# read command line
$fileIn=$ARGV[1];
foreach $_(@ARGV){
    next if ($_ eq $ARGV[1]);
    if   ($_=~/^fileOutRdb=(.*)$/) {$fileOutRdb=$1;}
    elsif($_=~/^fileOutHtml=(.*)$/){$fileOutHtml=$1;}
    elsif($_=~/^title=(.*)$/)      {$title=$1;}
    elsif($_=~/^noNali/)           {$LnoNali=1;}
    elsif($_=~/^noSeq/)            {$LnoSeq=1;}
    elsif($_=~/^organism=(.*)$/)   {$par{"organism"}=$1;}
    elsif($_=~/^nperline=(.*)$/)   {$par{"nperline"}=$1;}
#    elsif($_=~/^=(.*)$/)    {$=$1;}
    else {print"*** wrong command line arg '$_'\n";
	  die;}}

die ("missing input $fileIn\n") if (! -e $fileIn);

$LnoNali=    0              if (! defined $LnoNali);
$LnoSeq=     0              if (! defined $LnoSeq);
$tmp=$fileIn;$tmp=~s/^.*\/|\..*$//g;
$title=      $tmp           if (! defined $title);
$fileOutRdb= $title.".rdb"  if (! defined $fileOutRdb);
$fileOutHtml=$title.".html" if (! defined $fileOutHtml);
$par{"organism"}=$title     if (! defined $par{"organism"});
				# ------------------------------
$#id=$#len=$#nali=$#seq=0;	# (1) read file list
&open_file("$fhin", "$fileIn");
while (<$fhin>) {
    $_=~s/\n//g;
    next if (! -e $_);
    print "--- read $_\n"; $fileHssp=$_;
				# get NALIGN
    if (! $LnoNali){undef %rd; 
		    ($Lok,%rd)=&hsspRdHeader($fileHssp,"NALIGN","SEQLENGTH");
		    $nali=$rd{"NALIGN"};$len=$rd{"SEQLENGTH"};}
				# get sequence
    if (! $LnoSeq) {undef %rd; 
		    ($Lok,%rd)=&hsspRdSeqSecAcc($fileHssp,"*","*");
		    if (! $LnoSeq) {$seq="";
				    foreach $it (1..$rd{"NROWS"}){$seq.=$rd{"seq","$it"};}}}
				# get id
    $id=$fileHssp;$id=~s/^.*\///g;
    if ($id =~/\.hssp.*_([A-Z0-9])/){$chain=$1;}else{$chain=0;}
    $id=~s/\.hssp.*$//g;
    $id.=$chain if ($chain);
    push(@id,$id); push(@len,$len);
    push(@nali,$nali) if (! $LnoNali);
    push(@seq, $seq)  if (! $LnoSeq);}close($fhin);

				# ------------------------------
				# (2) write RDB
&open_file("$fhout",">$fileOutRdb"); 
print $fhout 
    "# Perl-RDB\n","# generated by $scrName ($fileIn)\n";
				# header
printf $fhout "# NOTATION %-5s : %-s\n","id",   "identifier of protein";
printf $fhout "# NOTATION %-5s : %-s\n","nali", "number of sequence in family";
printf $fhout "# NOTATION %-5s : %-s\n","len",  "length of protein";
printf $fhout "# NOTATION %-5s : %-s\n","seq",  "sequence (one letter amino acid code)";
				# names
print $fhout "id","\t","len";
print $fhout "\tnali"       if (! $LnoNali);
print $fhout "\tseq"        if (! $LnoSeq);
print $fhout "\n";
				# body
foreach $it (1..$#id){
    print $fhout $id[$it],"\t",$len[$it];
    print $fhout "\t",$nali[$it]   if (! $LnoNali);
    print $fhout "\t",$seq[$it]    if (! $LnoSeq);
    print $fhout "\n";}
close($fhout);
				# ------------------------------
				# (3) write output (HTML)
$Llink=1;
&rdb2htmlHere($fileOutRdb,$fileOutHtml,$fhout,$Llink);

print "--- output in $fileOutRdb,$fileOutHtml\n";

exit;



#==============================================================================
# library collected (begin) lll
#==============================================================================


#==============================================================================
sub hsspRdHeader {
    local ($fileInLoc,@kwdInLoc) = @_ ;
    local ($sbrName,$fhinLoc,$tmp,
	   @kwdDefHsspTopLoc,@kwdDefHsspHdrLoc,@kwdHsspTopLoc,@kwdHsspHdrLoc,@tmp,
	   $regexpBegHeader,$regexpEndHeader,$regexpLongId,$lenStrid,$LisLongId,
	   %ptr,$kwd,$Lok,$Lpdb,$des,$beg,$end,$mid,$ct,$id,$strid,$ptr,$tmp);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   hsspRdHeader                reads a HSSP header
#       in:                     $fileHssp (must exist), 
#         @kwdInLoc             = one of the default keywords 
#                               (@kwdLocHsspTop,@kwdLocHsspHeader)
#       in:                     'nopair' surpresses reading of pair information
#       out:                    for top  (e.g. NALIGN): $rd{"kwd"}
#                               for prot (e.g. LALI):   $rd{"kwd","$it"}
#                               note: for the later number of elements (it) in
#                                     $rd{"NROWS"}
#         special               ID=ID1, $rd{"kwd","$it"} existes for ID1 and ID2
#-------------------------------------------------------------------------------
    $sbrName="lib-br:hsspRdHeader";$fhinLoc="FHIN"."$sbrName";$fhinLoc=~tr/[a-z]/[A-Z]/;
				# file existing?
    if (! -e $fileInLoc || ! &is_hssp($fileInLoc) ){
	print "*** ERROR $sbrName no HSSP file '$fileInLoc'\n";
	return(0);}
				# ------------------------------
				# settings describing format
    @kwdDefHsspTopLoc= ("PDBID","DATE","SEQBASE","PARAMETER","THRESHOLD",
			"REFERENCE","HEADER","COMPND","SOURCE","AUTHOR",
			"SEQLENGTH","NCHAIN","KCHAIN","NALIGN");
    @kwdDefHsspHdrLoc= ("NR","ID","STRID","IDE","WSIM","IFIR","ILAS",
			"JFIR","JLAS","LALI","NGAP","LGAP","LSEQ2","ACCNUM","PROTEIN");
    $regexpBegHeader=   "^\#\# PROTEINS"; # begin of reading 
    $regexpEndHeader=   "^\#\# ALIGNMENTS"; # end of reading
    $regexpLongId=      "^PARAMETER  LONG-ID :YES"; # identification of long id

    $lenStrid=          4;	# minimal length to identify PDB identifiers
    $LisLongId=         0;	# long identifier names

    $ptr{"IDE"}=1;$ptr{"WSIM"}=2;$ptr{"IFIR"}=3;$ptr{"ILAS"}=4;$ptr{"JFIR"}=5;$ptr{"JLAS"}=6;
    $ptr{"LALI"}=7;$ptr{"NGAP"}=8;$ptr{"LGAP"}=9;$ptr{"LSEQ2"}=10; $ptr{"ACCNUM"}=11;

				# ------------------------------
				# check input arguments
    $#kwdHsspTopLoc=$#kwdHsspHdrLoc=$Lpdb=$LnoPair=0;
    foreach $kwd (@kwdInLoc){
	$Lok=0;
	if ($kwd eq "nopair"){
	    $LnoPair=1;
	    next;}
	$Lpdb=1 if (! $Lpdb && ($kwd =~/^PDBID/));
	foreach $des (@kwdDefHsspTopLoc)   {
	    if ($kwd eq $des){ $Lok=1; push(@kwdHsspTopLoc,$kwd);
			       last;}}
	next if ($Lok || $LnoPair);
	foreach $des (@kwdDefHsspHdrLoc){
	    if ($kwd eq $des){ $Lok=1; push(@kwdHsspHdrLoc,$kwd);
			       last;} }
	print "-*- WARNING $sbrName input kwd=$kwd, makes no sense??\n" if (! $Lok);}

				# force reading of NALI
    push(@kwdHsspTopLoc,"PDBID") if (! $Lpdb);
	
				# get column numbers to read
				# ------------------------------
				# now start to read
    $Lok=&open_file("$fhinLoc","$fileInLoc");
    if (! $Lok){print "*** ERROR $sbrName HSSP file could not be opened '$fileInLoc'\n";
		return(0);}
    undef %tmp;		# save space
				# ------------------------------
    while ( <$fhinLoc> ) {	# read top
	last if ($_ =~ /$regexpBegHeader/); 
	if ($_ =~ /$regexpLongId/) {
	    $LisLongId=1;}
	else{$_=~s/\n//g;$arg=$_;
	     foreach $des (@kwdHsspTopLoc){
		 if ($arg  =~ /^$des\s+(.+)$/){
		     if (defined $ok{"$des"}){ # multiple lines!
			 $tmp="$1"."\t";
			 if  (defined $tmp{"$des"}){
			     $tmp{"$des"}.=$tmp;}
			 else{$tmp{"$des"}=$tmp;}}
		     else {$ok{"$des"}=1;$tmp{"$des"}=$1;}
		     if ($des=~/SEQLENGTH|NCHAIN|KCHAIN|NALIGN/){
			 $tmp{"$des"}=~s/^(\d+)[^0-9]+.*$/$1/;} # purge blanks
		     last;}}}}
				# ------------------------------
    $ct=0;			# read header
    while ( <$fhinLoc> ) { 
	last if ($LnoPair);	# supress reading pair info
	last if ($_ =~ /$regexpEndHeader/); 
	next if ($_ =~ /^  NR\./); # skip descriptors
	$_=~s/\n//g;
	$lenLine=length($_);
	if ($LisLongId){
	    $maxMid=115; $maxMid=($lenLine-56) if ($lenLine < 115);
	    $maxEnd=109; $maxEnd=$lenLine  if ($lenLine < 109);
	    $beg=substr($_,1,56);
	    $end=0; $end=substr($_,109)        if ($lenLine >=109);
	    $mid=substr($_,57,115); }
	else {
	    $maxMid= 62; $maxMid=($lenLine-28) if ($lenLine <  90);
	    $beg=substr($_,1,28);
	    $end=0; $end=substr($_,90)         if ($lenLine >=90);
	    $mid=substr($_,29,90); }
	$end=~s/^\s*|\s*$//g;   # purge leading blanks
	$mid=~s/^\s*|\s*$//g;	# purge leading blanks
				# SWISS accession: hack because it may be empty!
	if ($lenLine > 86) {
	    $accnum=substr($_,81,6); $accnum=~s/(\s)\s+/$1/g ; }
	else {
	    $accnum=0;}
				# begin: counter and id
	$beg=~s/.+ \:\s*|\s*$//g;
	if (! $LisLongId) {$id=$beg;$id=~s/([^\s]+).*$/$1/;
			   $strid=$beg;$strid=~s/$id|\s//g; }
	else              {$id=$beg;$id=~s/(.+_\S+).*/$1/;
			   $strid=substr($_,49,6);$strid=~s/\s//g; }
	    $tmp=$lenStrid-1;
	if ( (length($strid)<$lenStrid) && ($id=~/^[0-9][A-Z0-9]{$tmp,$tmp}\s*/)){
	    $strid=substr($id,1,$lenStrid); }
	++$ct;

	$tmp{"ID","$ct"}=     $id;
	$tmp{"NR","$ct"}=     $ct;
	$tmp{"STRID","$ct"}=  $strid;
				# correct for ID = PDBid
	$tmp{"STRID","$ct"}=  $id if ($strid=~/^\s*$/ && 
				      $id=~/\d\w\w\w.?\w?$/);
	    
	$tmp{"PROTEIN","$ct"}=$end;
	$tmp{"ID1","$ct"}=$tmp{"PDBID"};
	$tmp{"ACCNUM","$ct"}=$accnum;
				# middle all info
	$#tmp=0;@tmp=split(/\s+/,$mid);
	foreach $_ (@tmp) {$_=~s/\s//g;}

	foreach $des (@kwdHsspHdrLoc){ 
	    next if ( ! defined $ptr{"$des"});
	    next if ( $des =~/^ACCNUM/);
	    $ptr=$ptr{"$des"};
	    $tmp{"$des","$ct"}=$tmp[$ptr]; }}close($fhinLoc);
    $tmp{"NROWS"}=$ct;
				# clean up
    $#kwdInLoc=$#kwdDefHsspHdrLoc=$#kwdHsspTopLoc=$#tmp=
	$#kwdDefHsspTopLoc=$#kwdHsspHdrLoc=0;
    undef %ptr;
    return(1,%tmp);
}				# end of hsspRdHeader

#==============================================================================
sub hsspRdSeqSecAcc {
    local($fileInLoc,$ifirLoc,$ilasLoc,$chain,@kwdRd) = @_ ;
    local($sbrName,$fhinLoc,$tmp,$line,$chainLoc,$seqNo,$pdbNo,$chainRd,$ifirRd,$ilasRd);
    $[=1;
#----------------------------------------------------------------------
#   hsspRdSeqSecAcc             reads the HSSP seq/sec/acc from ifir to ilas
#       in:                     file.hssp_C ifir ilas (* for all numbers, ' ' or '*' for chain)
#                               @kwdRd (which to read) = 0 for all
#       out:                    %rdLoc{"kwd","it"}
#                 @kwd=         ("seqNo","pdbNo","seq","sec","acc")
#                                'chain'
#----------------------------------------------------------------------
    $sbrName="lib-br:hsspRdSeqSecAcc";$fhinLoc="FHIN"."$sbrName";$fhinLoc=~tr/[a-z]/[A-Z]/;
				# file existing?
    $chainLoc=0;
    if    (defined $chain){
	$chainLoc=$chain;}
    elsif ($fileInLoc =~/\.hssp.*_(.)/){
	$chainLoc=$fileInLoc;$chainLoc=~s/^.+.hssp.*_(.)$/$1/;
	$fileInLoc=~s/^(.+.hssp.*)_(.)$/$1/;}

    if (! -e $fileInLoc){
	print "*** $sbrName: HSSP file '$fileInLoc' missing\n";
	return(0);}
    $ifirLoc=0  if (! defined $ifirLoc  || ($ifirLoc eq "*") );
    $ilasLoc=0  if (! defined $ilasLoc  || ($ilasLoc eq "*") );
    $chainLoc=0 if (! defined $chainLoc || ($chainLoc eq "*") );
    $#kwdRd=0   if (! defined @kwdRd);
    undef %tmp;
    if ($#kwdRd>0){
	foreach $tmp(@kwdRd){
	    $tmp{"$tmp"}=1;}}
				# ------------------------------
				# open file
    $Lok=&open_file("$fhinLoc","$fileInLoc");
    if (! $Lok){print "*** ERROR $sbrName could not open HSSP '$fileInLoc'\n";
		return(0);}
				# ------------------------------
    while (<$fhinLoc>) {	# header
	last if ( $_=~/^\#\# ALIGNMENTS/ ); }
    $tmp=<$fhinLoc>;		# skip 'names'
    $ct=0;
				# ------------------------------
				# read seq/sec/acc
    while (<$fhinLoc>) {
	$line=$_; $line=~s/\n//g;
	last if ( $_=~/^\#\# / ) ;
        $seqNo=  substr($line,1,6);$seqNo=~s/\s//g;
        $pdbNo=  substr($line,7,6);$pdbNo=~s/\s//g;
        $chainRd=substr($line,13,1);  # grep out chain identifier
	next if ( $chainLoc && ($chainRd ne $chainLoc));
	next if ( $ifirLoc  && ($seqNo < $ifirLoc));
	next if ( $ilasLoc  && ($seqNo > $ilasLoc));
	++$ct;$tmp{"NROWS"}=$ct;
        if (defined $tmp{"chain"}) { $tmp{"chain","$ct"}=$chainRd; }
        if (defined $tmp{"seq"})   { $tmp{"seq","$ct"}=  substr($_,15,1); }
	if (defined $tmp{"sec"})   { $tmp{"sec","$ct"}=  substr($_,18,1); }
	if (defined $tmp{"acc"})   { $tmp=               substr($_,37,3); $tmp=~s/\s//g;
				     $tmp{"acc","$ct"}=  $tmp; }
	if (defined $tmp{"seqNo"}) { $tmp{"seqNo","$ct"}=$seqNo; }
	if (defined $tmp{"pdbNo"}) { $tmp{"pdbNo","$ct"}=$pdbNo; }
    }
    close($fhinLoc);
            
    return(1,%tmp);
}                               # end of: hsspRdSeqSecAcc 

#==============================================================================
sub is_hssp {
    local ($fileInLoc) = @_ ;local ($fh,$Lis,$tmp);
#--------------------------------------------------------------------------------
#   is_hssp                     checks whether or not file is in HSSP format
#       in:                     $file
#       out:                    1 if is hssp; 0 else
#--------------------------------------------------------------------------------
				# highest priority: has to exist
    return (0)                  if (! -e $fileInLoc);
    $fh="FHIN_CHECK_HSSP";
    open($fh, $fileInLoc) || 
	do { print "*** ERROR is_hssp $fileInLoc not opened to $fh\n";
	     return (0) ;};	# missing file -> 0
    $tmp=<$fh>;			# first line
    close($fh);
				# is HSSP
    return(1)                   if (defined $tmp && $tmp=~/^HSSP/);
    return(0);
}				# end of is_hssp

#==============================================================================
sub open_file {
    local ($file_handle,$file_name,$log_file) = @_ ;
    local ($temp_name) ;
#-------------------------------------------------------------------------------
#   open_file                  opens file, writes warning asf
#-------------------------------------------------------------------------------
    $temp_name = $file_name ;
    $temp_name =~ s/^>>|^>//g ;
    if ( ($file_name =~ /^>>/ ) && ( ! -e $temp_name ) ) {
	print "*** INFO (open_file): append file=$temp_name, does not exist-> create it\n" ;
	open ($file_handle, ">$temp_name") || ( do {
	    warn "***\t Cannot create new file: $temp_name\n" ;
	    if ( $log_file ) {
		print $log_file "***\t Cannot create new file: $temp_name\n" ;}
	    return (0);
	} );
	close ("$file_handle") ;}
  
    open ($file_handle, "$file_name") || ( do {
	warn "*** ERROR lib-br:open_file: Cannot open file '$file_name'\n" ;
	if ( $log_file ) {
	    print $log_file "*** lib-br:open_file: Cannot create new file '$file_name'\n" ;}
	return(0);
    } );
    return(1);
}				# end of open_file



#==============================================================================
# library collected (end)   lll
#==============================================================================


1;
#==========================================================================================
sub rdb2htmlHere {
    local ($fileRdb,$fileHtml,$fhout,$Llink) = @_ ;
    local (@headerRd,$tmp,@tmp,@colNames,$colNames,%body,$des,$ct,$fhin);
    $[ =1 ;
#--------------------------------------------------------------------------------
#    sub: rdb2html              convert an RDB file to HTML
#         input:		$fileRdb,$fileHtml,$fhout,$Llink 
#                               (Llink=1 -> links from column names to Notation in header)
#--------------------------------------------------------------------------------
    $fhin="FHinRdb2html";
    &open_file("$fhin", "$fileRdb"); # external lib-ut.pl
    
    $#headerRd=0;		# ------------------------------
    while (<$fhin>) {		# read header of RDB file
	$tmp=$_;$_=~s/\n//g;
	last if (! /^\#/);
	push(@headerRd,$_);}
				# ------------------------------
				# get column names
    $tmp=~s/\n//g;$tmp=~s/^\t*|\t*$//g;
    @colNames=split(/\t/,$tmp);

    $body{"COLNAMES"}="";	# store column names
    foreach $des (@colNames){$body{"COLNAMES"}.="$des".",";}
	
    $ct=0;			# ------------------------------
    while (<$fhin>) {		# read body
	next if ($_=~/\t\d+[NFD\t]\t/); # skip format
	$_=~s/\n//g;$_=~s/^\t*|\t*$//g;	# purge leading
	next if (length($_)<1);
	@tmp=split(/\t/,$_);
	++$ct;
	foreach $it (1..$#tmp){	# store body
	    $key=$colNames[$it];
	    $body{"$ct","$key"}=$tmp[$it];}}
    $body{"NROWS"}=$ct;
				# end of reading RDB file
				# ------------------------------

				# ------------------------------
				# write output file
    &open_file("$fhout", ">$fileHtml") if ($fhout ne "STDOUT");
    @tmp=			# write header   external lib-ut.pl
	&wrtRdb2HtmlHeaderHere($fhout,$Llink,$body{"COLNAMES"},@headerRd);
				# mark keys to be linked
    foreach $col (@colNames){$body{"link","$col"}=0;}
    foreach $col (@tmp)     {$body{"link","$col"}=1;}
	
				# write body
    &wrtRdb2HtmlBodyHere($fhout,$Llink,%body);

    close($fhin);close($fhout) if ($fhout ne "STDOUT");
}				# end of rdb2htmlHere

#==========================================================================================
sub wrtRdb2HtmlHeaderHere {
    local ($fhout,$LlinkLoc,$colNamesLoc,@headerLoc) = @_ ;
    local (@colNamesLoc,$Lnotation,$LlinkHere,$col,@namesLink);
    $[ =1 ;
#--------------------------------------------------------------------------------
#   wrtRdb2HtmlHeader		write the HTML header
#         input:		$fhout,$fileLoc,$LlinkLoc,$colNamesLoc,@headerLoc
#                               where colName="name1,name2,"
#                               and @headerLoc contains all lines in header
#         output:               @nameLinks : names of columns with links (i.e.
#                               found as NOTATION in header line
#--------------------------------------------------------------------------------
    $#namesLink=0;

    $colNamesLoc=~s/^,*|,*$//g;
    @colNamesLoc=split(/,/,$colNamesLoc);

    print $fhout 
	"<HTML>\n",
	"<TITLE>Database search results for ",$par{"organism"},"</TITLE>\n",
	"<BODY>\n",
	"<CENTER>\n",
	"<H1>Database search results for ",$par{"organism"},"</H1>\n",
	"<H2>Burkhard Rost</H2>\n",
	"<P><P>\n",
	"</CENTER>\n",
	"\n",
	"<P><P>\n",
	"<FONT SIZE=2> 69 012 Heidelberg, Germany, ",
	"<A HREF=\"mailto:rost\@EMBL-Heidelberg.de\">rost\@embl-heidelberg.de</A>, ",
	"<A HREF=\"http://www.embl-heidelberg.de/~rost/\">http://www.embl-heidelberg.de/~rost/</A>",
	"<BR> </FONT>\n",
	"\n",
	"<P><P>\n",
	"\n",
	"<UL>\n",
	"<LI><A HREF=\"\#HEADER\">Header (descriptions of column names)</A>",
	"<LI><A HREF=\"\#BODY\">  Table<A>",
	"</UL>\n",
	"<P><P>\n",
	"\n",
	"\n",
	"<HR>\n",
	"<P><P>\n",
	"<A NAME=\"HEADER\"><H2>Header (description of column names)</H2></A>\n",
	"<P><P>\n";

    print $fhout "<PRE>\n";
    $Lnotation=0;undef %ok;
    foreach $_(@headerLoc){
	$LlinkHere=0;$Lnotation=1 if ($_=~/NOTATION/);
	$_=~s/^\s*\#\s*//g;
	if ($Lnotation){
	   foreach $col(@colNamesLoc){
	       $LlinkHere=0;
		if ($_=~/NOTATION\s*$col[\s\:]+/){ 
		    $colFound=$col;$LlinkHere=1;
		    if (! defined $ok{$col}){$ok{$col}=1;
					     push(@namesLink,$col);}
		    last;}}
	   if ($LlinkLoc && $LlinkHere){ 
		print $fhout "<A NAME=\"$colFound\">";}}
	print $fhout "$_";
	if ($LlinkHere){
	   print $fhout "</A>";}
	print $fhout "\n";}
    print $fhout "\n</PRE>\n";
    print $fhout "<BR>\n";
    return(@namesLink);
}				# end of wrtRdb2HtmlHeaderHere

#==========================================================================================
sub wrtRdb2HtmlBodyHere {
    local ($fhout,$LlinkLoc,%bodyLoc) = @_ ;
    $[ =1 ;
#--------------------------------------------------------------------------------
#   wrtRdb2HtmlBodyHere		writes the body for a RDB->HTML file
#                               where $body{"it","colName"} contains the columns
#--------------------------------------------------------------------------------
    print $fhout 
	"<P><P><HR><P><P>\n\n",
	"<A NAME=\"BODY\"><H2>Table</H2><\/A>\n",
	"<P><P>\n";
				# get column names
    $bodyLoc{"COLNAMES"}=~s/^,*|,*$//g;
    @colNames=split(/,/,$bodyLoc{"COLNAMES"});

    print $fhout "<TABLE BORDER>\n";
				# ------------------------------
    				# write column names with links
    &wrtRdb2HtmlBodyColNamesHere($fhout,@colNames);

				# ------------------------------
				# write body
    foreach $it (1..$body{"NROWS"}){
	print $fhout "\n<TR>   ";
	foreach $itdes (1..$#colNames){
	    if    ($colNames[$itdes]=~/^(num|nali|len)/){
		print $fhout "<TD ALIGN=RIGHT>";}
	    elsif ($colNames[$itdes]=~/^(id|seq)/){
		print $fhout "<TD ALIGN=LEFT>";}
	    else {print $fhout "<TD>";}
	    
	    if (defined $body{"$it","$colNames[$itdes]"} && $colNames[$itdes] eq "seq") {
		$seq=$body{"$it","$colNames[$itdes]"};
		if ($par{"nperLine"}>=length($seq)){
		    print $fhout $seq;}
		else{
		    $seqTmp="";
		    for ($res=1;$res<=(length($seq)-$par{"nperLine"});$res+=$par{"nperLine"}){
			$len=$par{"nperLine"}; 
			$len=(length($seq)-$res) if ((length($seq)-$res)<$par{"nperLine"});
#			$seqTmp.=substr($seq,$res,$len)." ";
			$seqTmp.=substr($seq,$res,$len)."<BR>";
		    }
		    print $fhout $seqTmp;}}
	    elsif (defined $body{"$it","$colNames[$itdes]"}){
	    	print $fhout $body{"$it","$colNames[$itdes]"};}
	    else {print $fhout " ";} 
	    print $fhout "</TD>";}
	print $fhout "</TR>\n";
				# ------------------------------
				# repeat names
	if (int($it/50)==($it/50)){
	    &wrtRdb2HtmlBodyColNamesHere($fhout,@colNames);}

    }

    print $fhout "\n";
    print $fhout "</TABLE>\n";
    print $fhout "\n\n";
				# ------------------------------
				# final words
    print $fhout
	"<P><P><BR><BR><P><P>\n"."<HR>\n"."<!--"."=" x 50 ."-->\n\n",
	"<A HREF=\"http://www.embl-heidelberg.de/\"> ",
	"<IMG WIDTH=50 HEIGHT=50 ALIGN=MIDDLE SRC=\"../Dfig/icon-embl.gif\" ALT=\"EMBL Home\"></A> \n",
	"<A HREF=\"../index.html\">",
	"<IMG WIDTH=50 HEIGHT=50 ALIGN=MIDDLE SRC=\"../Dfig/icon-br-home.gif\" ALT=\"Rost Home\"></A>\n",
	"<A HREF=\"mailto:rost\@EMBL-Heidelberg.de\">",
	"<IMG WIDTH=50 HEIGHT=50 ALIGN=MIDDLE SRC=\"../Dfig/icon-br-home-mail.gif\" ALT=\"Mail to Rost\"></A>\n\n",
	"<A HREF=\"http://www.embl-heidelberg.de/predictprotein/predictprotein.html\">",
	"<IMG ALIGN=MIDDLE WIDTH=50 HEIGHT=50 SRC=\"../Dfig/icon-pp.gif\" ALT=\"PredictProtein\"></A>\n",
	"<A HREF=\"http://www.embl-heidelberg.de/~rost/aqua.html\">",
	"<IMG ALIGN=MIDDLE WIDTH=50 HEIGHT=50 SRC=\"../Dfig/icon-aqua.gif\" ALT=\"Aqua Home\"></A>\n\n",
	"</BODY>\n","</HTML>\n";
	

}				# end of wrtRdb2HtmlBodyHere

#==========================================================================================
sub wrtRdb2HtmlBodyColNamesHere {
    local ($fhout,@colNames)=@_;
    $[ =1 ;
#--------------------------------------------------------------------------------
#   WrtRdb2HtmlBodyColNames   writes the column names (called by previous)
#       GLOBAL input:		%bodyLoc
#         input:                $fhout,@colNames
#--------------------------------------------------------------------------------
    print $fhout "<TR ALIGN=LEFT>  ";
    foreach $des (@colNames){
	print $fhout "\t<TH>";
	if ($LlinkLoc && $bodyLoc{"link","$des"}){
	    print $fhout "<A HREF=\"\#$des\">";}
	print $fhout $des," ";
	if ($LlinkLoc && $bodyLoc{"link","$des"}){
	    print $fhout "</A>";}
	print $fhout "</TH>\n";
    }
    print $fhout "</TR>\n";
}				# end of wrtRdb2HtmlBodyColNamesHere

