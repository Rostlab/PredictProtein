#!/usr/sbin/perl -w
#
#
$scriptName=$0;$scriptName=~s/^.*\/|\.pl//g;
#
# statistics on file hsspHeader.rdb (generated by hssp_extr_header.pl)
# note: histograms will be refined later when merging the split files!
#
$[ =1 ;

				# include libraries
push (@INC, "/home/rost/perl") ;if (! defined $ENV{'PERLLIB'}){push(@INC,$ENV{'PERLLIB'});}
require "ctime.pl";
require "lib-ut.pl"; require "lib-prot.pl"; require "lib-comp.pl";
				# defaults

$interv= 1;			# compute histogram for every percentage point

#@colRd=       ("NoAll","NoOne","ID1","ID","IDE","WSIM","LEN1","LEN2","LALI","NGAP","LGAP");
@kwdOutDet=   ("id1","id2","pide","psim","lali","ngap","lgap","len1","len2","energy","zscore");
%ptrOutDet=   ('id1',"2",'id2',"3",'pide',"4",'psim',"5",'lali',"6",'lgap',"7",'ngap',"8",
	       'len1',"9",'len2',"10",'energy',"11",'zscore',"12");
@kwdOutDetDis=("old","ide","sim");
#@kwdTmpHisto= ("pide","psim","Dold","Dide","Dsim","Dadd","DiOs","DiGs");
#@kwdOutDis=   ("dist",
#	       "nold","nCold","nTold","nFold","nTCold","nFCold",
#	       "nide","nCide","nTide","nFide","nTCide","nFCide",
#	       "nsim","nCsim","nTsim","nFsim","nTCsim","nFCsim",
#	       "nadd","nCadd","nTadd","nFadd","nTCadd","nFCadd",
#	       "niOs","nCiOs","nTiOs","nFiOs","nTCiOs","nFCiOs",
#	       "niGs","nCiGs","nTiGs","nFiGs","nTCiGs","nFCiGs");
#@kwdOutIde=   ("pide","n","nC","nT","nTC","nF","nFC");
#@kwdOutSim=   ("pide","n","nC","nT","nTC","nF","nFC");

#@kwdTmpHisto= ("pide","psim","Dold","Dide","Dsim","DsGi");
@kwdTmpHisto= ("pide","psim","Dold","Dide","Dsim","DsGi","energy","zscore");
#@kwdOutDis=   ("dist",
#	       "nTold","nFold","nTCold","nFCold",
#	       "nTide","nFide","nTCide","nFCide",
#	       "nTsim","nFsim","nTCsim","nFCsim",
#	       "nTsGi","nFsGi","nTCsGi","nFCsGi");
#@kwdOutIde=   ("pide","nT","nTC","nF","nFC");
#@kwdOutSim=   ("pide","nT","nTC","nF","nFC");

$thresh{"ide"}="250,390,0.55";$thresh{"sim"}="250,430,0.5";

$fhin="FHIN";
$fhout="FHOUT";$fhoutDetTrue="FHOUT_TRUE";$fhoutDetFalse="FHOUT_FALSE";

$fileTrue=  "/home/rost/pub/data/truePairs849Triangle.dat";
$fileTrue=  "/home/rost/pub/data/truePairs849.list";
$fileTrue=  "/home/rost/pub/data/truePairs849Hand.dat";
$fileIgnore="/home/rost/pub/data/truePairs849Ignore.dat";
$Lverb= 1;
$Lverb2=1;
$Lverb3=0;
				# initialise variables
if ($#ARGV<1){
    print "goal:   statistics on hsspHeader.rdb (generated by hssp_extr_header.pl)\n";
    print "        *************************************************\n";
    print "NOTE:   !!!!   actually works on the merged version  !!!!\n";
    print "            i.e. first run hsspHdrRdbMerge on id*rdb     \n";
    print "        *************************************************\n";
    print "usage:  script hsspHeader.rdb \n";
    print "\n";
    print "option: title=\n";
    print "        true=x file-with-standard-of-truth (def=$fileTrue)\n";
    print "        ignore=fileIgnore                  (def=$fileIgnore)\n";
    print "note:   'ignore' on command line will read default ignore file \n";
    print "        and ignore all pairs found in there\n";
    print "note2:  histograms will be generated later: on level of det* files!\n";
    exit;}

$fileIn=$ARGV[1];

$Lignore=0;$#fileIn=0;
foreach $_ (@ARGV){
    if   (/^not(_?[sS]creen|_?[vV]erbose)/) {$Lverb=0;}
    elsif(/^verbose/)    {$Lverb=1;}
    elsif(/^verb2/)      {$Lverb2=1;}
    elsif(/^verb3/)      {$Lverb3=1;}
    elsif(/^title=(.+)$/){$title=$1;}
    elsif(/^ignore$/ )     {$Lignore=1;}
    elsif(/^ignore=(.+)$/) {$fileIgnore=$1;}
    elsif(/^true=(.+)$/)   {$fileTrue=$1;}
    elsif(-e $_){
	push(@fileIn,$_);print "--- input file '$_'\n";}
    else{print "*** unrecognised argument '$_'\n";
	 exit;}}
if (! $#fileIn){push(@fileIn,$fileIn);}

				# --------------------------------------------------
				# read true
if (! -e $fileTrue){print "*** ERROR $scriptName: fileTrue '$fileTrue' missing\n";
		    exit;} if ($Lverb){print "--- reading fileTrue \t $fileTrue\n";}
&open_file("$fhin", "$fileTrue"); # external lib-ut.pl
while(<$fhin>){$_=~s/\n//g;
	       ($tmp1,$tmp2)=split(/\t/,$_);
	       $id1=substr($tmp1,1,4); # purge chains
	       $tmp2=~s/,$//g;
	       @tmp2=split(/,/,$tmp2);
	       foreach $tmp2 (@tmp2){
		   $id2=substr($tmp2,1,4); # purge chains
		   if (! defined $true{"$id1,$id2"}){
		       $true{"$id1,$id2"}=1;}}}close($fhin);
				# --------------------------------------------------
if ($Lignore){			# read ignore
    if (! -e $fileIgnore){print "*** ERROR blastHeaderRdb2stat: fileIgnore '$fileIgnore' missing\n";
			  exit;}if ($Lverb){print "--- reading fileIgnore \t $fileIgnore\n";}
    &open_file("$fhin", "$fileIgnore"); # external lib-ut.pl
    while(<$fhin>){$_=~s/\n//g;
		   ($tmp1,$tmp2)=split(/\t/,$_);
		   $id1=substr($tmp1,1,4); # purge chains
		   $tmp2=~s/,$//g;
		   @tmp2=split(/,/,$tmp2);
		   foreach $tmp2 (@tmp2){
		       $id2=substr($tmp2,1,4); # purge chains
		       if (! defined $ignore{"$id1,$id2"}){
			   $ignore{"$id1,$id2"}=1;}}}close($fhin);}
				# --------------------------------------------------
foreach $fileIn (@fileIn){	# loop over many input files
				# ------------------------------
				# unique title for output files
    $title=$fileIn; $title=~s/^.*\///g;$title=~s/OutDet|-all.*|\.dat//g;$title=~s/Out-?|\.rdb//g;
    $fileOutDet=      "det-".   "$title".".dat";
#    $fileOutIde=      "ide-".   "$title".".dat";
#    $fileOutSim=      "sim-".   "$title".".dat";
#    $fileOutDis=      "dis-".   "$title".".dat";
    $fileOutDetTrue=  $fileOutDet;$fileOutDetTrue=~s/[dD]et-/detT-/;
    $fileOutDetFalse= $fileOutDet;$fileOutDetFalse=~s/[dD]et-/detF-/;
				# ------------------------------
				# open output files for details
    &open_file("$fhoutDetTrue", ">$fileOutDetTrue");
    &open_file("$fhoutDetFalse", ">$fileOutDetFalse");
    foreach $fhLoc("$fhoutDetTrue","$fhoutDetFalse"){
	if ($fhLoc eq "$fhoutDetTrue"){$tmp="T";}else{$tmp="F";}
	print $fhLoc 
	    "id1$tmp\tid2$tmp\tpide$tmp\tpsim$tmp\tlali$tmp\tngap$tmp\tlgap$tmp\t",
	    "len1$tmp\tlen2$tmp\tenergy$tmp\tzscore$tmp\tdold$tmp\tdIde$tmp\tdSim$tmp\n";}
				# --------------------------------------------------
				# now read Header.rdb
    &open_file("$fhin", "$fileIn"); # external lib-ut.pl
    undef %ok; undef %res;
    foreach $kwd(@kwdTmpHisto){$tmp1=$kwd;$tmp2="T".$kwd;$tmp3="F".$kwd;
			       foreach $tmp("$tmp1","$tmp2","$tmp3"){
				   foreach $it(-100..100){
				       $res{"$tmp","$it"}=0;}}}
    if ($Lverb){print "--- reading fileHeader \t $fileIn\n";}
				# only if directly reading id.rdb!!
    if (0){
	while(<$fhin>){$_=~s/\n//g; # quick skip header
		       if (/^\#\s*LEN1\s*:\s*(\d+)/){$len1=$1;$len1=~s/\s//g;}
		       last if (/^pos/);}
    }
    while(<$fhin>){
	$_=~s/\n//g;
	next if (/^\#|^NoAll|^id1|^pos|[\s|\t]\d+N/); # skip comments asf
#	++$ct; if ($ct>100){last;}	# xx
	$_=~s/^[\s\t]*|[\s\t]*$//g; undef %tmp;
	@tmp=split(/[\t\s]+/,$_);foreach $tmp(@tmp){$tmp=~s/\s//g;}
	foreach $kwd(@kwdOutDet){$pos=$ptrOutDet{"$kwd"};
				 if (0){ # only for direct read XXX
				     if ($kwd eq "len1"){$tmp{"$kwd"}=$len1;}
				     else {$tmp{"$kwd"}=$tmp[$pos];}}
				 else {
				     $tmp{"$kwd"}=$tmp[$pos];}}
    
#	foreach $kwd(@kwdOutDet){print "xx found kwd=$kwd, tmp=",$tmp{"$kwd"},",\n";}
				# ------------------------------
				# exclude pairs occurring twice
	$id1=$tmp{"id1"};$id2=$tmp{"id2"};$tmpId="$id1,$id2";
	if (defined $ok{"$tmpId"}){
	    if ($Lverb2){print "--- excluded as double \t $tmpId\n";}
	    next;}$ok{"$tmpId"}=1;
				# ------------------------------
	if ($Lignore){		# ignore
	    $Lskip=&getIgnoreFromList($tmp{"id1"},$tmp{"id2"});}
	next if $Lskip;
				# ------------------------------
				# true or false?
	$Ltrue=&getTrueFromList($tmp{"id1"},$tmp{"id2"});
				# get distances
	$tmp{"Dold"}=$tmp{"pide"}-&getDistanceHsspCurve($tmp{"lali"});	# external lib-prot
	$tmp{"Dold"}=75  if ($tmp{"Dold"}>75); # saturate (<100%)
				# ------------------------------
				# exclude unlikely false positives
	if (!$Ltrue && 0){	# xx commented out Jan 98
	    if   ($tmp{"Dold"}>=8){ # exclude above 10%
		print "xx excluded as dist>, $id1|$id2\n";
		next;}
	    elsif(($tmp{"Dold"}>=5)&&(rand()<0.2)){ # include every 3rd between 5-10
		print "xx excluded as dist:5-10, $id1|$id2\n";
		next;}
	}
				# ------------------------------
	foreach $des (@kwdOutDetDis){ # compile distances
	    next if ($des =~ /^old/);
	    $tmpDes="D".$des;
	    if    ($des eq "ide"){
		$tmp{"$tmpDes"}=$tmp{"pide"}-&getHsspThreshNewIde($tmp{"lali"});}
	    elsif ($des eq "sim"){
		$tmp{"$tmpDes"}=$tmp{"psim"}-&getHsspThreshNewSim($tmp{"lali"});}
	    $tmp{"$tmpDes"}=75  if ($tmp{"$tmpDes"}>75); }  # saturate (<100%)
				# ------------------------------
				# write details T/F
	if ($Ltrue){$fhLoc=$fhoutDetTrue;}else{$fhLoc=$fhoutDetFalse;}
	foreach $kwd (@kwdOutDet){
	    if ($Lverb3){print $tmp{"$kwd"},"|\t";}
	    print $fhLoc $tmp{"$kwd"},"\t";}
				# write distances
	foreach $des (@kwdOutDetDis){
	    if ($des eq $kwdOutDetDis[$#kwdOutDetDis]){$tmp="\n";}else{$tmp="\t";}
	    $tmpDes="D".$des;
	    if ($Lverb3){printf "%6.2f$tmp",$tmp{"$tmpDes"};}
	    printf $fhLoc "%6.2f$tmp",$tmp{"$tmpDes"}; }
	next;			# commented out 23.1.98: do later!! (xx)
				# ------------------------------
	$Lok=0;			# compute statistics
	foreach $des (@kwdTmpHisto){
	    $Lexcl=0;
	    if    ($des eq "DsGi"){ # count only if psim > pide
		if ($tmp{"pide"} > $tmp{"psim"}){
		    $Lexcl=1;}
		else {
		    $tmp=&fRound($tmp{"Dide"});}}
	    elsif ($des eq "Dadd"){ # add over thresh ide AND sim
		$tmp=($tmp{"Dide"}+$tmp{"Dsim"})/2;
		$tmp=&fRound($tmp);}
	    elsif ($des eq "DiOs"){ # count only if over either ide OR sim
		if    ($tmp{"Dide"}>0){$tmp=&fRound($tmp{"Dide"});}
		elsif ($tmp{"Dsim"}>0){$tmp=&fRound($tmp{"Dsim"});}
		else  {$Lexcl=1;}}
	    else {
		$tmp=&fRound($tmp{"$des"}); }  # external lib-comp.pl
	    if ($tmp>75){$tmp=75;}elsif($tmp<-100){$tmp=-100;}
	    if (! $Lexcl){
		++$res{"$des","$tmp"};
		if ($Ltrue){$tmpDes="T"."$des";}else{$tmpDes="F"."$des";}
		++$res{"$tmpDes","$tmp"};}}
    }close($fhin);close($fhoutDetTrue);close($fhoutDetFalse);
				# ------------------------------
				# write output files
#    &wrtDis($fileOutDis,@kwdOutDis);
#    &wrtIde($fileOutIde,@kwdOutIde);
#    &wrtSim($fileOutSim,@kwdOutSim);

    print "--- output in $fileOutDetTrue,$fileOutDetFalse\n";
#    print "--- output in $fileOutDetTrue,$fileOutDetFalse,$fileOutIde,$fileOutSim,$fileOutDis\n";
}
exit;

#==========================================================================================
sub getDistanceHsspCurveNew {
    local ($lali,$laliMax,$n0,$pot) = @_ ;
    $[=1;
#--------------------------------------------------------------------------------
#   getDistanceHsspCurveNew     computes the HSSP curve for input: ali length
#        input:                 $lali
#                               note1: thresh=0 for HSSP, 5 for 30%, -5 for 20% ..
#                               note2: saturation at 100
#        output:                value curve (i.e. percentage identity)
#                               HSSP-curve  according to t(L)=(290.15 * L ** -0.562)
#--------------------------------------------------------------------------------
    $lali=~s/\s//g;if (!defined $laliMax){$laliMax=100;}
	
    if ($lali>$laliMax){$lali=$laliMax;}
    $val= $n0*($lali **(-1*$pot)); 
    return ($val);
}				# end getDistanceHsspCurveNew

#===============================================================================
sub getIgnoreFromList {
    local($id1Loc,$id2Loc) = @_ ;
    local($sbrName,$fhinLoc,$tmp);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getIgnoreFromList           compares actual two ids with those read from fileTrue
#       GLOBAL                  $true{"id1,id2"}
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."getTrueFromList";$fhinLoc="FHIN"."$sbrName";

    $tmpId1=substr($id1Loc,1,4);$tmpId2=substr($id2Loc,1,4);
				# first four identical
    if (defined $ignore{"$tmpId1,$tmpId2"}){
	return(1);}
				# different number
    elsif (substr($tmpId1,2,3) eq substr($tmpId2,2,3)){ # same protein,
	$ignore{"$tmpId1,$tmpId2"}=1;
	return(1);}
    else{
	return(0);}
}				# end of getIgnoreFromList

#===============================================================================
sub getTrueFromList {
    local($id1Loc,$id2Loc) = @_ ;
    local($sbrName,$fhinLoc,$tmp,$Lok);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getTrueFromList             compares actual two ids with those read from fileTrue
#       GLOBAL                  $true{"id1,id2"}
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."getTrueFromList";$fhinLoc="FHIN"."$sbrName";

    $tmpId1=substr($id1Loc,1,4);$tmpId2=substr($id2Loc,1,4);
				# first four identical
    if (defined $true{"$tmpId1,$tmpId2"}){
	return(1);}
				# different number
    elsif (substr($tmpId1,2,3) eq substr($tmpId2,2,3)){ # same protein,
	$true{"$tmpId1,$tmpId2"}=1;
	return(1);}
    else{
	return(0);}
}				# end of getTrueFromList

#===============================================================================
sub wrtDis {
    local($fileOutLoc,@kwdLoc)=@_;
    $[ =1 ;
#-------------------------------------------------------------------------------
#   wrtDis                      writes histogram for distances from HSSP thresh
#       out:                    all GLOBAL
#-------------------------------------------------------------------------------
    $fhout="FHOUT_LOCAL";
    @fhLoc=("$fhout"); if ($Lverb2){push(@fhLoc,"STDOUT");}

    $tmp=$interv;$#interv=0;
    while( (100-$tmp)>=-100){
	push(@interv,(100-$tmp));$tmp+=$interv;}
				# write file
    &open_file("$fhout", ">$fileOutLoc");
				# header
    foreach $fhLoc(@fhLoc){
	if ($fhLoc eq "STDOUT"){$sep="  ";}else{$sep="\t";}
	foreach $kwd(@kwdLoc){if ($kwd eq $kwdLoc[$#kwdLoc]){$fin="\n";}else{$fin=$sep;}
			      print $fhLoc "$kwd$fin";}}
				# ------------------------------
				# write histogram
				# set zero cumulative stuff
    foreach $kwdLoc(@kwdLoc){next if ($kwdLoc !~/C/);
			     $loc{"$kwdLoc"}=0;$loc{"$kwdLoc"."F"}=0;$loc{"$kwdLoc"."T"}=0;}

    foreach $it(1..$#interv){	# loop over all distances
#	$dist=$interv[$#interv-$it+1];
	$dist=$interv[$it];
				# ignore 0 counts
	if (($res{"Dold","$dist"}+$res{"Dide","$dist"}+$res{"Dsim","$dist"})==0){
	    next;}
				# intermediate store and cumulative
	foreach $kwdLoc(@kwdLoc){
	    next if ($kwdLoc=~/C|^dist/);
	    $des= $kwdLoc;$des=~s/^n//g;$des="D".$des;$des=~s/^DT/TD/;$des=~s/^DF/FD/;
	    $kwdc=$kwdLoc;$kwdc=~s/^n([TF]?)(.*)$/n$1C$2/;
	    $loc{"$kwdLoc"}=$res{"$des","$dist"}; # simple
	    $loc{"$kwdc"}+= $res{"$des","$dist"}; } # cumulative
				# write
	foreach $fhLoc(@fhLoc){
	    if ($fhLoc eq "STDOUT"){$sep=" ";}else{$sep="\t";}
	    print $fhLoc "$dist";
	    foreach $kwdLoc(@kwdLoc){next if ($kwdLoc =~ /^dist/);
				     print $fhLoc "$sep",$loc{"$kwdLoc"};}
	    print $fhLoc "\n";}
    }close($fhout); 
}				# end of wrtDis

#===============================================================================
sub wrtIde {
    local($fileOutLoc,@kwdLoc)=@_;
    $[ =1 ;
#-------------------------------------------------------------------------------
#   wrtIde                      writes histogram for pide from HSSP thresh
#       out:                    all GLOBAL
#-------------------------------------------------------------------------------
    $fhout="FHOUT_LOCAL";
    $tmp=$interv;$#interv=0;
    while( (100-$tmp)>=0){
	push(@interv,(100-$tmp));$tmp+=$interv;}
				# write file
    &open_file("$fhout", ">$fileOutLoc");
				# header
    foreach $kwd(@kwdLoc){if ($kwd eq $kwdLoc[$#kwdLoc]){$fin="\n";}else{$fin="\t";}
			  print $fhout "$kwd$fin";}
				# ------------------------------
				# write histogram
    $nc=$nct=$ncf=0;
    foreach $it(1..$#interv){	# loop over all distances
#	$pide=$interv[$#interv-$it+1];
	$pide=$interv[$it];
				# ignore 0 counts
	if ($res{"pide","$pide"}==0){
	    next;}
	print $fhout "$pide";
	$n= $res{"pide","$pide"};$nc+=$n; # old
	$nt=$res{"Tpide","$pide"};$nct+=$nt;$nf=$res{"Fpide","$pide"};$ncf+=$nt;
	print $fhout "\t$nt\t$nct\t$nf\t$ncf";
	print $fhout "\n";
    }
    close($fhout); 
}				# end of wrtIde

#===============================================================================
sub wrtSim {
    local($fileOutLoc,@kwdLoc)=@_;
    $[ =1 ;
#-------------------------------------------------------------------------------
#   wrtSim                      writes histogram for distances from HSSP thresh
#       out:                    all GLOBAL
#-------------------------------------------------------------------------------
    $fhout="FHOUT_LOCAL";
    $tmp=$interv;$#interv=0;
    while( (100-$tmp)>=0){
	push(@interv,(100-$tmp));$tmp+=$interv;}
				# write file
    &open_file("$fhout", ">$fileOutLoc");
				# header
    foreach $kwd(@kwdLoc){if ($kwd eq $kwdLoc[$#kwdLoc]){$fin="\n";}else{$fin="\t";}
			  print $fhout "$kwd$fin";}
				# ------------------------------
				# write histogram
    $nc=$nct=$ncf=0;
    foreach $it(1..$#interv){	# loop over all simances
#	$sim=$interv[$#interv-$it+1];
	$sim=$interv[$it];
				# ignore 0 counts
	if ($res{"psim","$sim"}==0){
	    next;}
	print $fhout "$sim";
	$n= $res{"psim","$sim"};$nc+=$n; # old
	$nt=$res{"Tpsim","$sim"};$nct+=$nt;$nf=$res{"Fpsim","$sim"};$ncf+=$nt;
	print $fhout "\t$nt\t$nct\t$nf\t$ncf";
	print $fhout "\n";
    }
    close($fhout); 
}				# end of wrtSim

#===============================================================================
sub getHsspThreshNewIde {
    local($laliLoc)=@_; local($expon,$loc);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getHsspThreshNewIde         out=NewIde (i.e. HSSP threshold on psim)
#       in:                     $lali
#       out:                    $pide
#                               pide= 510 * L ^ { -0.32 (1 + e ^-(L/1000)) }
#-------------------------------------------------------------------------------
    $expon= - 1 * 0.32 * ( 1 + exp (-$laliLoc/1000) );
    $loc= 510 * $laliLoc ** ($expon);
    return($loc);
}				# end of getHsspThreshNewIde

#===============================================================================
sub getHsspThreshNewSim {
    local($laliLoc)=@_; local($expon,$loc);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getHsspThreshNewSim         out=NewSim (i.e. HSSP threshold on psim)
#       in:                     $lali
#       out:                    $sim
#                               psim= 420 * L ^ { -0.335 (1 + e ^-(L/2000)) }
#-------------------------------------------------------------------------------
    $expon= - 0.335 * ( 1 + exp (-$laliLoc/2000) );
    $loc= 420 * $laliLoc ** ($expon);
    return($loc);
}				# end of getHsspThreshNewSim

