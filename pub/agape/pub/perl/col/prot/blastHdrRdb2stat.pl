#!/usr/sbin/perl -w
#
# statistics on file blast.blastOut (generated by hack-runANDextrBlast.pl)
#
$[ =1 ;

				# include libraries
push (@INC, "/home/rost/perl") ;if (! defined $ENV{'PERLLIB'}){push(@INC,$ENV{'PERLLIB'});}
require "ctime.pl";
require "lib-ut.pl"; require "lib-prot.pl"; require "lib-comp.pl";
				# defaults
@kwdOutDet=   ("id1","id2","pide","lali","blScor","blProb");
%ptrOutDet=   ('id1',"1",'id2',"2",
	       'pide',"3",'lali',"4",'blScor',"5",'blProb',"6");

$fhin="FHIN";
$fhoutDetTrue="FHOUT_TRUE";$fhoutDetFalse="FHOUT_FALSE";$fhout="FHOUT";

$Lverb= 1;
$Lverb2=1;
$Lverb3=0;			# xx

$grid=100;			# int(score*$grid) for histograms
$fileTrue=  "/home/rost/pub/data/truePairs849.list";
$fileTrue=  "/home/rost/pub/data/truePairs849Triangle.dat";

$fileTrue=  "/home/rost/pub/data/truePairs849Hand.dat";

$fileIgnore="/home/rost/pub/data/truePairs849Ignore.dat";
				# initialise variables
if ($#ARGV<1){
    print"goal:   statistics on blastHeader.rdb  (generated by blastHeaderRdb2stat)\n";
    print"usage:  script hsspHeader.rdb \n";
    print"option: title=x\n";
    print"        true=fileTrue                  (def=$fileTrue)\n";
    print"        ignore=fileIgnore              (def=$fileIgnore)\n";
    print"note:   'ignore' on command line will read file \n        \t \t $fileIgnore\n";
    print"        and ignore all pairs found in there\n";
	      exit;}

$Lignore=0;
$#fileIn=0;
foreach $_ (@ARGV){
    if   (/^not(_?[sS]creen|_?[vV]erbose)/) {$Lverb=0;}
    elsif(/^verbose/)      {$Lverb=1;}
    elsif(/^verb2/)        {$Lverb2=1;}
    elsif(/^verb3/)        {$Lverb3=1;}
    elsif(/^ignore$/ )     {$Lignore=1;}
    elsif(/^ignore=(.+)$/) {$fileIgnore=$1;}
    elsif(/^true=(.+)$/)   {$fileTrue=$1;}
    elsif(/^title=(.+)$/)  {$title=$1;}
    elsif(-e $_){
	push(@fileIn,$_);print "--- input file '$_'\n";}
    elsif(! -e $_){print "*** unrecognised argument '$_'\n";
		   exit;}}
				# --------------------------------------------------
				# read true
if (! -e $fileTrue){print "*** ERROR blastHeaderRdb2stat: fileTrue '$fileTrue' missing\n";
		    exit;}
if ($Lverb){print "--- reading fileTrue \t $fileTrue\n";}
&open_file("$fhin", "$fileTrue"); # external lib-ut.pl
while(<$fhin>){$_=~s/\n//g;
	       ($tmp1,$tmp2)=split(/\t/,$_);
	       $id1=substr($tmp1,1,4); # purge chains
	       $tmp2=~s/,$//g;
	       @tmp2=split(/,/,$tmp2);
	       foreach $tmp2 (@tmp2){
		   $id2=substr($tmp2,1,4); # purge chains
		   if (! defined $true{"$id1,$id2"}){
		       $true{"$id1,$id2"}=1;}}}close($fhin);
				# --------------------------------------------------
				# read ignore
if ($Lignore){
    if (! -e $fileIgnore){
	print "*** ERROR blastHeaderRdb2stat: fileIgnore '$fileIgnore' missing\n";
	exit;}
    if ($Lverb){print "--- reading fileIgnore \t $fileIgnore\n";}
    &open_file("$fhin", "$fileIgnore"); # external lib-ut.pl
    while(<$fhin>){$_=~s/\n//g;
		   ($tmp1,$tmp2)=split(/\t/,$_);
		   $id1=substr($tmp1,1,4); # purge chains
		   $tmp2=~s/,$//g;
		   @tmp2=split(/,/,$tmp2);
		   foreach $tmp2 (@tmp2){
		       $id2=substr($tmp2,1,4); # purge chains
		       if (! defined $ignore{"$id1,$id2"}){
			   $ignore{"$id1,$id2"}=1;}}}close($fhin);}
				# --------------------------------------------------
				# loop over files
foreach $fileIn(@fileIn){
    next if (! -e $fileIn);
    $title=$fileIn; $title=~s/^.*\///g;$title=~s/\..*$//g;

    $fileOutDet=      "det-".  "$title".".dat";
    $fileOutDetTrue=  $fileOutDet;$fileOutDetTrue=~s/det-/detT-/;
    $fileOutDetFalse= $fileOutDet;$fileOutDetFalse=~s/det-/detF-/;

    $fileOutHisScore= "scoreHis-"."$title".".dat";
    $fileOutHisProb=  "probHis-". "$title".".dat";
				# open files for details
    $Lok1=&open_file("$fhoutDetTrue",  ">$fileOutDetTrue"); 
    $Lok2=&open_file("$fhoutDetFalse", ">$fileOutDetFalse");
    if (! $Lok1 || !$Lok2){print"*** problems opening '$fileOutDetTrue,$fileOutDetFalse'\n";
			   next;}
    
    foreach $fhLoc("$fhoutDetTrue","$fhoutDetFalse"){
	if ($fhLoc eq "$fhoutDetTrue"){$tmp="T";}else{$tmp="F";}
	print $fhLoc "id1$tmp\tid2$tmp\tpide$tmp\tlali$tmp\tblScor\tblProb\n";}
				# --------------------------------------------------
				# now read Header.rdb
    &open_file("$fhin", "$fileIn"); # external lib-ut.pl
    $#prob=$#probS=$#score=$#scoreS=0;
    undef %tmp; undef %nhis; undef %ok;
    
    if ($Lverb){print "--- reading fileHeader \t $fileIn\n";}
    $ctpair=0;			# xx
    while(<$fhin>){
	$_=~s/\n//g;
	next if (/^\#|^id/); # skip header
	$_=~s/^\s*|\s*$//g;
	undef %tmp; $#tmp=0;
	@tmp=split(/\t/,$_);foreach $tmp(@tmp){$tmp=~s/\s//g;}
	foreach $kwd(@kwdOutDet){
	    $pos=$ptrOutDet{"$kwd"};$tmp{"$kwd"}=$tmp[$pos];}
	$tmp{"blProb"}=~s/^e/1e/;	# correct new blast: e-100 -> 1e-100
				# ------------------------------
				# exclude pairs occurring twice
	$id1=$tmp{"id1"};$id2=$tmp{"id2"};$tmpId="$id1,$id2";$tmpId=~s/_//g; # skip chain
	if (defined $ok{"$tmpId"}){if ($Lverb2){print "--- excluded as double \t $tmpId\n";}
				   next;}$ok{"$tmpId"}=1;
				# ------------------------------
				# ignore
	if ($Lignore){
	    $Lskip=&getIgnoreFromList($tmp{"id1"},$tmp{"id2"});}
	next if $Lskip;
				# ------------------------------
				# true or false?
	$Ltrue=&getTrueFromList($tmp{"id1"},$tmp{"id2"});
				# assign file handle
	if ($Ltrue){$fhLoc=$fhoutDetTrue;}
	else       {$fhLoc=$fhoutDetFalse;}
				# score statistics
	$score=$tmp{"blScor"};$score=~s/\s//g;
	$prob= $tmp{"blProb"};$prob=~s/\s//g;
	next if ($prob <= 0);	# stop if score <=0 (no logarithm possible)
	$probLg=&funcLog($prob,10);
	$probSort=int($grid*$probLg);++$ctpair;
	if ((! defined $nhis{"tp","$probSort"})&&(! defined $nhis{"fp","$probSort"})){
	    push(@prob,$probSort);}
	if ((! defined $nhis{"ts","$score"})&&(! defined $nhis{"fs","$score"})){
	    push(@score,$score);}
	if ($Ltrue){if (! defined $nhis{"ts","$score"})   {  $nhis{"ts","$score"}=1;}
		    else                                  {++$nhis{"ts","$score"};}
		    if (! defined $nhis{"tp","$probSort"}){  $nhis{"tp","$probSort"}=1;}
		    else                                  {++$nhis{"tp","$probSort"};}}
	else       {if (! defined $nhis{"fs","$score"})   {  $nhis{"fs","$score"}=1;}
		    else                                  {++$nhis{"fs","$score"};}
		    if (! defined $nhis{"fp","$probSort"}){  $nhis{"fp","$probSort"}=1;}
		    else                                  {++$nhis{"fp","$probSort"};}}
	foreach $kwd (@kwdOutDet){
	    if ($kwd eq $kwdOutDet[$#kwdOutDet]){$sep="\n";}else{$sep="\t";}
	    if ($Lverb3){print $tmp{"$kwd"},$sep;}
	    print $fhLoc $tmp{"$kwd"},$sep;}
    }close($fhin);close($fhoutDetTrue);close($fhoutDetFalse);
    
				# ------------------------------
				# do histogram
    &open_file("$fhout", ">$fileOutHisScore");
    @scoreS=sort bynumber_high2low (@score);	# sort
    &wrtHis("$fhout","score",@scoreS);
    close($fhout);
    
    &open_file("$fhout", ">$fileOutHisProb");
    @probS=sort bynumber (@prob);	# sort

    &wrtHis("STDOUT","prob",@probS);
    &wrtHis("$fhout","prob",@probS);
    close($fhout);
    print "xx $ctpair\n";
}
print "--- output in $fileOutDetTrue,$fileOutDetFalse,$fileOutHisScore,$fileOutHisProb\n";
exit;

#===============================================================================
sub getTrueFromList {
    local($id1Loc,$id2Loc) = @_ ;
    local($sbrName,$fhinLoc,$tmp);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getTrueFromList             compares actual two ids with those read from fileTrue
#       GLOBAL                  $true{"id1,id2"}
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."getTrueFromList";$fhinLoc="FHIN"."$sbrName";

    $tmpId1=substr($id1Loc,1,4);$tmpId2=substr($id2Loc,1,4);
				# first four identical
    if (defined $true{"$tmpId1,$tmpId2"}){
	return(1);}
				# different number
    elsif (substr($tmpId1,2,3) eq substr($tmpId2,2,3)){ # same protein,
	$true{"$tmpId1,$tmpId2"}=1;
	return(1);}
    else{
	return(0);}
}				# end of getTrueFromList

#===============================================================================
sub getIgnoreFromList {
    local($id1Loc,$id2Loc) = @_ ;
    local($sbrName,$fhinLoc,$tmp);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   getTrueFromList             compares actual two ids with those read from fileTrue
#       GLOBAL                  $true{"id1,id2"}
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."getTrueFromList";$fhinLoc="FHIN"."$sbrName";

    $tmpId1=substr($id1Loc,1,4);$tmpId2=substr($id2Loc,1,4);
				# first four identical
    if (defined $ignore{"$tmpId1,$tmpId2"}){
	return(1);}
				# different number
    elsif (substr($tmpId1,2,3) eq substr($tmpId2,2,3)){ # same protein,
	$ignore{"$tmpId1,$tmpId2"}=1;
	return(1);}
    else{
	return(0);}
}				# end of getTrueFromList

#===============================================================================
sub subx {
#    local($fileInLoc) = @_ ;
    local($sbrName,$fhinLoc,$tmp,$Lok);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   subx                       
#                               c
#       in:                     
#         A                     A
#       out:                    
#         A                     A
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."subx";$fhinLoc="FHIN"."$sbrName";

    $Lok=       &open_file("$fhinLoc","$fileInLoc");
    if (! $Lok){print "*** ERROR $sbrName: '$fileInLoc' not opened\n";
		return(0);}
    while (<$fhinLoc>) {
	$_=~s/\n//g;
	next if (length($_)==0);
    } close($fhinLoc);

}				# end of subx

#===============================================================================
sub wrtHis{
    local($fhLoc,$txtLoc,@tmpLoc) = @_ ;
    local($tmp,$ctT,$ctF);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   wrtHis                      writes histogram
#-------------------------------------------------------------------------------
    if ($scriptName){$tmp="$scriptName".":";}else{$tmp="";}
    $sbrName="$tmp"."wrtHis";$fhinLoc="FHIN"."$sbrName";

    printf $fhLoc "%-10s","$txtLoc";
    print $fhLoc "\tNtrue\tNfalse\tNCtrue\tNCfalse\n";
    $ctT=$ctF=0;
    foreach $tmp (@tmpLoc){		# histogram (score)
	$kwdT="t".substr($txtLoc,1,1);
	$kwdF="f".substr($txtLoc,1,1);
	if    ($txtLoc eq "score"){
	    printf $fhLoc "%-10d",$tmp;}
	elsif ($txtLoc eq "prob"){
	    $format="%"."-10.".(length($grid)-1)."f";
	    printf $fhLoc "$format",($tmp/$grid);}
#	    printf $fhLoc "%-10.5f",($tmp/$grid);}
	else {
	    print "*** ERROR $sbrName txtLoc=$txtLoc, not undestood\n";
	    die;}
	if (! defined $nhis{"$kwdT","$tmp"}){
	    print $fhLoc "\t",0;}
#	    print $fhLoc "\t","";}
	else {$ctT+=$nhis{"$kwdT","$tmp"};
	      print $fhLoc "\t",$nhis{"$kwdT","$tmp"};}
	if (! defined $nhis{"$kwdF","$tmp"}){
	    print $fhLoc "\t",0;}
#	    print $fhLoc "\t","";}
	else {$ctF+=$nhis{"$kwdF","$tmp"};
	      print $fhLoc "\t",$nhis{"$kwdF","$tmp"};}
	print $fhLoc "\t",$ctT,"\t",$ctF,"\n";
    }
}				# end of wrtHis

