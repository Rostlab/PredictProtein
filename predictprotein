#!/usr/bin/perl -w
use warnings;
use strict;
use Data::Dumper;
use Carp qw(cluck :DEFAULT);
use Getopt::Long;
use File::Copy;
use File::Temp;
use File::Basename;
use Pod::Usage;
use Config::IniFiles;
use Bio::Seq;
use Bio::SeqIO;
use RG::PP::CacheMgr;

$Carp::Verbose = 1; 

my $warn = "---";
my $err = "***";

# SYSTEM CONFIGURATION RETRIEVAL
our $config;
my ($pp_rootdir,$librg_utils_perl);
BEGIN {
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
    $ENV{PATH} = "/bin:/usr/bin";
    my ( $defaultconfig, $etcconfig );
    if( -e "__pkgdatadir__/predictproteinrc.default" ) { $defaultconfig = Config::IniFiles->new( -file => "__pkgdatadir__/predictproteinrc.default" ); }
    if( -e "__sysconfdir__/predictproteinrc" ) { $etcconfig = Config::IniFiles->new( -file => "__sysconfdir__/predictproteinrc", -import => $defaultconfig ); } else { $etcconfig = $defaultconfig; }
    if( ( $ENV{PREDICTPROTEINCONF} && -e "$ENV{PREDICTPROTEINCONF}" ) || -e "$ENV{HOME}/.predictproteinrc" ) { $config = Config::IniFiles->new( -file => $ENV{PREDICTPROTEINCONF} || "$ENV{HOME}/.predictproteinrc", -import => $etcconfig ); } else { $config = $etcconfig; }
}

# NOTE: all configuration can be overridden by command line options
$pp_rootdir  = glob($config->val('predictprotein', 'predictprotein_utildir')).'/';
$librg_utils_perl = glob($config->val('predictprotein', 'librg_utils_perl')).'/' || '/usr/share/librg-utils-perl/';
my $db_blast_train = glob($config->val('blast', 'uniref'));
my $db_blast_final = glob($config->val('blast', 'uniref90'));
my $prof_app_root = glob($config->val('support_apps', 'prof'));
my $proftmb_app_root = glob($config->val('support_apps', 'proftmb'));
my $root_dir = $pp_rootdir || "__pkgdatadir__";
my $make_file = $root_dir."/MakefilePP.mk";
my $use_cache = $config->val('predictprotein', 'use_cache');

#my $output_format = "text";
my $work_dir;

# COMMAND LINE OPTIONS
my( $help, $man, $dbg, $dry_run, $prot_name, @method, $output_dir, $seqfile, $sequence_in, $setacl, @target, $version);
#my $input_file;

my $force_cache_store = 0;
my $num_cpus = 1;
my $blast_processors = 1;

if (@ARGV < 1){ die "Usage: $0 [OPTIONS]\n";}

my $result = GetOptions (
          'acl|setacl=s' => \$setacl,
			    "blast-processors=i" => \$blast_processors,
			    "c|num-cpus=i" =>\$num_cpus,
			    "d|debug!" => \$dbg,
#			    "f|output-format=s" => \$output_format,
          "force-cache-store!" => \$force_cache_store,
			    "help|?" => \$help,
#          "i|input-file=s" => \$input_file,
			    "m|make-file=s" =>\$make_file,
			    "man" => \$man,
          'method=s@' => \@method,
			    "n|dryrun" => \$dry_run,
			    "o|output-dir=s" => \$output_dir,
			    "p|prot-name=s" =>\$prot_name,
			    "s|seq|sequence=s" =>\$sequence_in,
          'seqfile=s' => \$seqfile,
          'target=s@' => \@target,
          'use-cache!' => \$use_cache,
			    "v|version" => \$version,
			    "w|work-dir=s" => \$work_dir
) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;
if ($version){
    print STDERR qq|This is PredictProtein version __pkgver__

Copyright 1992-2010, Rostlab

Please see COPYING file for license information

Complete documentation for PredictProtein,  should be found on
this system using "man predictprotein" or at http://www.predictprotein.org/.

|;
    exit (0);
}

my( $makemethod, $maketarget, $hash_meth ) = _get_makemethod( \@method );

if( !$output_dir && !$use_cache ){ die("Error: no output directory given and no cache is to be used. Results would be lost unless you use --output-dir or --use-cache.".( $dbg ? '' : "\n" ) ); }
if( $output_dir )
{
  $output_dir = glob($output_dir);
  system( 'mkdir', '-p', $output_dir ) && die( "could not mkdir '$output_dir': ".($? >> 8 ));
}

if(! $prot_name){ $prot_name="query"; }
if( $prot_name =~ /[^[:alnum:]._-]/o ){ die("Error: invalid protein name, please use only [[:alnum:] -._]".( $dbg ? '' : "\n" )); }

# check acl syntax if given
if( $setacl ) { RG::PP::CacheMgr::acl2hash( $setacl ); }

if( !@target ){ @target = ( 'all' ); }
if( $target[0] ne 'all' ){ push @target, @$maketarget; } # all is `all', no need to specify them individually

if( ! $work_dir ){ $work_dir = File::Temp::tempdir( CLEANUP => !$dbg ); }
else { $work_dir = glob($work_dir); system ( "mkdir", '-p', $work_dir ) && die( "could not mkdir '$work_dir': ".($? >> 8) ); }

if( $seqfile )
{
  my $in = Bio::SeqIO->new( ( $seqfile eq '-' ? ( -fh => \*STDIN ) : ( -file => scalar( glob( $seqfile ) ) ) ), -format => 'Fasta' );
  my $seq = $in->next_seq();
  $sequence_in = $seq->seq();
}


# COLLECT USER INPUT
#if( $input_file )
#{
#  my $user_params = Config::IniFiles->new( -file =>  glob($input_file) );
#  if( !defined ($user_params) ){ confess("$err Cannot read user parameter file. Exiting."); }
#}

# Get sequence
$sequence_in || die("Error: no input sequence".( $dbg ? '' : "\n" ));

# work_seq_file holds sequence information and resides in intermediate work directory
my $work_seq_file = "$work_dir/$prot_name.in";

if( ! -e $work_seq_file )
{
  my $seqobj = Bio::Seq->new( -display_id => $prot_name, -seq => $sequence_in);
  my $seqout= Bio::SeqIO->new( -format => 'Fasta', -file => ">$work_seq_file" );
  $seqout->write_seq($seqobj);
}

# get number of processors on this host
#my @num_cpus=();
#if (!($num_cpus) && -e '/proc/cpuinfo'){
#     @num_cpus=`grep processor /proc/cpuinfo`;
#     $num_cpus = scalar(@num_cpus);
#}

# PRINT OUT JOB ENV
if ($dbg){ cluck "work_dir=$work_dir"; }

# cache fetch?
if( $use_cache && !$force_cache_store )
{
  # Do we have it in the cache?
  my @ppf_cmd = ('ppc_fetch', '--seq', $sequence_in );

  #   method
  push @ppf_cmd, map {
    my $method = $_;
    my $ctrl = join(',', map {
      my $ctrl = $_; "$ctrl=$hash_meth->{$method}->{ctrl}->{$ctrl}";
    } keys(%{$hash_meth->{$method}->{ctrl}}) );
    ( '--method', $method.( $ctrl ? ",$ctrl" : '' ) );
  } keys(%$hash_meth);

  if( $dbg ){ cluck( "@ppf_cmd" ); }

  my( $closeret, @cachefiles );
  {
    my $pid = open( my $pipe, '-|' ); if( !defined( $pid ) ){ die("failed to execute '|@ppf_cmd': ".( $? >> 8 )); }
    if( !$pid ){ exec( @ppf_cmd ); }
    @cachefiles = <$pipe>;
    $closeret = close( $pipe );
  }
  #
  if( $closeret )
  {
    # in cache, so we do not run but copy files to $output_dir if that's given
    if( $output_dir )
    {
      foreach my $cfile (@cachefiles)
      {
        chomp( $cfile );

        # set filename to $prot_name
        my( $filename, $directories, $suffix ) = fileparse( $cfile, qr/\.[^.]*$/o );

        my $dfile = "$output_dir/$prot_name$suffix";

        my @cp_cmd = ( 'cp', '--preserve=timestamps', $cfile, $dfile );
        system( @cp_cmd ) && confess( "failed to execute '@cp_cmd': ".( $? >> 8 ) );
      }

      if( $dbg ){ warn( "prediction fetched from cache, results are in $output_dir" ); }
    }
    exit(0);
  }
}




# RUN MAKEFILE
my @cmd = ();
push (@cmd,"make");
push (@cmd,"INFILE=$work_seq_file");
if( $work_dir ){ push (@cmd,"WORKDIR=$work_dir/"); }
push (@cmd,"JOBID=".$prot_name);
push (@cmd, "-n") if ($dry_run);
push (@cmd, "-j", $num_cpus);
push (@cmd, "BLASTCORES=".$blast_processors);
push (@cmd, "LIBRGUTILS=".$librg_utils_perl);
push (@cmd, "PPROOT=".$pp_rootdir);
push (@cmd, "PROFROOT=".$prof_app_root);
push (@cmd, "PROFTMBROOT=".$proftmb_app_root);
push (@cmd, @$makemethod );
if( !$dbg ){ push @cmd, '--quiet'; } else { push (@cmd, "DEBUG=".$dbg); }

if ($make_file){
    push( @cmd, "-f", scalar( glob($make_file) ) );
}

# target
my @cmd_all = ( @cmd, @target );

my $oldout;
if($dbg) { cluck("@cmd_all"); }
else
{
  # so the methods speak on standard out ... let's just silence them all
  open( $oldout, '>&', \*STDOUT ) || die( $! );
  open( STDOUT, '>', '/dev/null' ) || die( $! );
}
                system(@cmd_all) && die( "@cmd_all failed: ".($? >> 8 ) );
if( !$dbg ) { open( STDOUT, '>&', $oldout ) || die( $! ); }

# cache store?
if( $use_cache )
{
  # We have to combine method ctrl params (%$hash_meth) with result files here and that is not trivial. We are going to have logic here to establish which result file belongs to which method.
  # Associate extensions with method names: %RG::PP::CacheMgr::meth_ext_hash
  my $precache_dir = File::Temp::tempdir( CLEANUP => !$dbg );
  if( $dbg ){ warn("precache dir = $precache_dir"); }
   
  my @cmd_install = ( @cmd, "DESTDIR=$precache_dir", 'install' );
  if ($dbg) { cluck("@cmd_install"); }
  system( @cmd_install ) && die( "@cmd_install DESTDIR=$precache_dir install failed: ".( $? >> 8 ) );

  my $result_files = _ls_dir( $precache_dir );
  foreach my $res_file (@$result_files)
  {
    if( substr( $res_file, 0, 1 ) eq '.' ){ next; }

    # query.aliBlastpSwiss => $method->{blastpswiss}->{res}->{aliBlastpSwiss} = "$precache_dir/$res_file";
    my( $filename, $directories, $suffix ) = fileparse( $res_file, qr/\.[^.]*$/o );
    my $extkey = substr( $suffix, 1 );

    my $method = $RG::PP::CacheMgr::meth_ext_hash{$extkey};
    if( !$method ){ warn("Warning: extension '$extkey' does not have associated method in RG::PP::CacheMgr::meth_ext_hash"); $method = $extkey; }

    $hash_meth->{$method}->{res}->{$extkey} = "$precache_dir/$res_file";
  }
  #if( $dbg ){ cluck( Dumper( $hash_meth ) ); }

  # Now call ppc_store
  my @method_args = map {
    my $method = $_;
    my $ctrl = join(',', map { my $cp = $_; "$cp=$hash_meth->{$method}->{ctrl}->{$cp}"; } keys(%{$hash_meth->{$method}->{ctrl}}) );
    my $res = join(',', map { my $res = $_; "res_$res=$hash_meth->{$method}->{res}->{$res}"; } keys(%{$hash_meth->{$method}->{res}}) );
    "--method=$method".( $ctrl ? ",$ctrl" : '' ).($res ? ",$res" : '' );
  } keys(%$hash_meth);

  my @cmd = (
    'ppc_store',
    ( $setacl ? ( '--setacl', $setacl ) : () ),
    @method_args,
    '--seq', $sequence_in
  );

  if( $dbg ){ cluck( "@cmd" ); }
  system( @cmd ) && die( "@cmd failed: ".( $? >> 8 ) );
}

if( $output_dir )
{
  my @cmd_install = ( @cmd, "DESTDIR=$output_dir", 'install' );

  if ($dbg) { cluck("@cmd_install"); }
  system( @cmd_install ) && die( "@cmd_install DESTDIR=$output_dir install failed: ".( $? >> 8 ) );

  if( $dbg ){ warn( "prediction complete, results are in $output_dir" ); }
}

exit(0);



# method - translate and pass --method=asp,ws=3,... --method=... method control parameters to make file
# idea: translate control params simply like this: --method=MNAME,CTRLP1=CTRLVAL1, -> NMAMECTRL=--CTRLP1=CTRLVAL1
# Also return all methods as targets.
sub               _get_makemethod
{
  my( $__method ) = @_;
  my $makemethod = [];
  my $maketarget = [];
  my $hash_meth = {};

  foreach my $method_cm ( @$__method )
  {
    # split each string in two parts:method and res 
    my ($meth1, $rest)= split /,/o, $method_cm, 2; 

    push @$maketarget, $meth1;
  
    # split rest after and save in an array
    my @tmp_hash; if( $rest ){ @tmp_hash = split /,/o, $rest; }
  
    #look for the crtl and res elements for each method
    my @tmp_crl = grep( !/^res_/o, @tmp_hash );
    my @tmp_res = grep( /^res_/o, @tmp_hash );

    if( @tmp_res ){ warn( "Warning: `res_'-type parameters were given ('@tmp_res') - these are ignored by this program\n" ); }

    if( @tmp_crl )
    {
      # Certain methods like profbval do not accept Getopt::Long-style cmd line parameters. That's bad. We can not pass parameters to such methods because we do not want to program special cases for them.
      # The long term solution is to make these methods accept Getopt::Long params.
      if(
        $meth1 eq 'prof' ||
        $meth1 eq 'profbval' ||
        $meth1 eq 'norsnet'
      ){ die("Error: this interface does not support passing control parameters to $meth1 because of ${meth1}'s primitive command line interface.".( $dbg ? '' : "\n" )); }
    }
  
    #store the results from each crt and res element as one hash
    push @$makemethod, uc( $meth1 ).'CTRL="'.join(' ', map {
      my $ctrlpair = $_;
      if( $ctrlpair =~ /^-/o ){ confess( "Error: control parameter with leading `-': '$ctrlpair'" ); } "--$_";
    } @tmp_crl ).'"';
    
    my $ctrl = { map{ split(/=/o, $_, 2 ); }@tmp_crl };
    $hash_meth->{$meth1}{'ctrl'} = $ctrl;
  }

  return( $makemethod, $maketarget, $hash_meth );
}


sub               _ls_dir
{
  my( $__dir ) = @_;
  opendir( my $dh, $__dir ) || confess( "failed to open $__dir: $!" );
  my $files = [ readdir( $dh ) ];
  closedir( $dh );
  return $files;
}


__END__

=head1 NAME

predictprotein - Protein sequence analysis suite

=head1 SYNOPSIS

predictprotein [options] [file ...]

=head1 DESCRIPTION

predictprotein runs a set of protein sequnce analysis methods.  Method outputs are deposited into B<--output-dir>.  If no B<--output-dir> is given but B<--use-cache> is in effect it will store and fetch results from the cache.

=head1 OPTIONS

=over

=item B<--acl>, B<--setacl>

Set access control lists.  Access control lists are set I<only> in case results are stored in the cache.  This option is ineffective otherwise.
All previous ACLs are lost - no merging.  The read bit controls browsability of results. Other bits are not used. E.g.

 u:lkajan:4,u:gyachdav:4,g:lkajan:4,o::0

=item B<--blast-processors>

Number of processors to use, default = 1

=item B<-c>, B<--num-cpus>

Make jobs, default = 1

=item B<-d>, B<--debug>

A lot of verbiage

=item B<--force-cache-store>

=item B<--noforce-cache-store>

Enable/disable forcing storage of results into cache.  Ineffective unless B<--use-cache> is also set.  Default: B<--noforce-cache-store>

=item B<--help>

Print a brief help message and exits.

=item B<-m>, B<--make-file>

make file to use, default = __pkgdatadir__/MakefilePP.mk

=item B<--man>

This documentation page

=item B<--method>

Describes method control parameters and requests methods to run when B<--target> is not I<all>. Format example:
 
 --method=profasp,ws=3
 
* begin with the method name, e.g. `profasp'

* list method control parameters, e.g. ws=3

Not all methods support passing control parameters in this way due to their primitive command line interfaces.

=item B<-n>, B<--dryrun>

Do not execute, just shows what is about to be run

=item B<-o>, B<--output-dir>

Final location of outputfiles, required unless caching is used.

=item B<-p>, B<--prot-name>

Query name, default = `query'

=item B<-s>, B<--seq>, B<--sequence>

one letter amino acid sequence input

=item B<--seqfile>

FASTA amino acid sequence file; if `-', standard input is read

=item B<--target>

Method groups to run. Default: `all'.  Look at the Makefile for a list of targets (``Use the source Luke'').

=item B<--use-cache>

=item B<--nouse-cache>

Use/do not use cache for predictprotein results. If enabled retrieve and store results automatically. Default: B<--nouse-cache>.

Option `use_cache' may be given in configuration files to override default.

=item B<-v>, B<--version>

Print package version

=item B<-w>, B<--work-dir>

Working directory, optional

=back

=head1 EXAMPLES

 predictprotein --seqfile __pkgdatadir__/example/tquick.fasta --output-dir /tmp/$USER/pp 

 predictprotein --seqfile __pkgdatadir__/example/tquick.fasta --method=profasp,ws=3 --output-dir /tmp/$USER/pp 

=over

=item Store results in cache, do not care about storing files in B<--output-dir>:

 predictprotein --seqfile __pkgdatadir__/example/tquick.fasta --method=profasp,ws=3 --use-cache --setacl g:rostlab:7

=item If not in cache store, otherwise fetch results from cache into B<--output-dir>:

 predictprotein --seqfile __pkgdatadir__/example/tquick.fasta --method=profasp,ws=3 --use-cache --setacl g:rostlab:7 --output-dir /tmp/$USER/pp

=back

=head1 ENVIRONMENT

=over

=item PREDICTPROTEINCONF

Location of predictproteinrc configuration file to use, overriding other configuration files

=back

=head1 FILES

=over

=item F<__pkgdatadir__/predictproteinrc.default>

Default configuration file. See this file for a description of the parameters.

=item F<__sysconfdir__/predictproteinrc>

System configuration file overriding values in F<__pkgdatadir__/predictproteinrc.default>

=back

=head1 AUTHOR

Burkhard Rost, Antoine de Daruvar, Jinfeng Liu, Guy Yachdav, Laszlo Kajan, Markus Schmidberger

=head1 SEE ALSO

ppqsub(1),  ppc_store(1),  ppc_fetch(1)

=cut

# vim:et:ts=2:ai:
