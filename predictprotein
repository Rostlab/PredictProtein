#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Carp qw(cluck croak confess longmess);
use Getopt::Long;
use File::Copy;
use File::Temp;
use File::Basename;
use Pod::Usage;
use Config::IniFiles;

use RG::Utils::Hssp_filter;
use RG::Utils::Copf;
use RG::Utils::Conv_hssp2saf;
use RG::Dudek::Blastpgp;

use lib './RG'; 
use RG::PP;  

$Carp::Verbose = 1; 

my $warn = "---";
my $err = "***";

# SYSTEM CONFIGURATION RETRIEVAL
our $config;
my ($pp_rootdir,$librg_utils_perl, $librg_dudek_perl);
BEGIN {
    my ( $defaultconfig, $etcconfig );
    if( -e "/usr/share/predictprotein/predictprotein.default" ) { $defaultconfig = Config::IniFiles->new( -file => "/usr/share/predictprotein/predictprotein.default" ); }
    if( -e "/etc/predictproteinrc" ) { $etcconfig = Config::IniFiles->new( -file => "/etc/predictproteinrc", -import => $defaultconfig ); } else { $etcconfig = $defaultconfig; }
    if( ( $ENV{PREDICTPROTEINCONF} && -e "$ENV{PREDICTPROTEINCONF}" ) || -e "$ENV{HOME}/.predictproteinrc" ) { $config = Config::IniFiles->new( -file => $ENV{PREDICTPROTEINCONF} || "$ENV{HOME}/.predictproteinrc", -import => $etcconfig ); } else { $config = $etcconfig; }
    
}

# NOTE: all configuration can be overridde by command line options
$pp_rootdir  = glob($config->val('predictprotein', 'predictprotein_utildir'));
$librg_utils_perl = glob($config->val('predictprotein', 'librg_utils_perl')) || '/usr/share/librg-utils-perl';
$librg_dudek_perl = glob($config->val('predictprotein', 'librg_dudek_perl')) || '/usr/share/librg_dudek_perl';
my $db_blast_train = glob($config->val('blast', 'uniref'));
my $db_blast_final = glob($config->val('blast', 'uniref90'));
my $root_dir = $pp_rootdir || "__PREFIX__/usr/share/predictprotein/";
my $make_file = $root_dir."/makepp.mk";
my $main_make_file = $root_dir."/makepp.mk";  # TODO NEED TO REORGNAIZE makefiles in a way that they can call each other
my $output_format = "text";
my $temp_dir = File::Temp::tempdir( CLEANUP => 0 );

# COMMAND LINE OPTIONS
my ($help, $man, $dbg, $dry_run,$proc_name, $input_file,$output_file);

if (@ARGV < 1){ die "Usage: $0 --input_file=<file>  +[OPTIONS] [process_id]\n";}

my $result = GetOptions (   "i|input_file=s" => \$input_file,
			    "o|output_file=s" => \$output_file,
			    "m|make_file=s" =>\$make_file,
			    "p|proc_name=s" =>\$proc_name,
			    "t|temp_dir=s" => \$temp_dir,
			    "n|dryrun" => \$dry_run,
			    "f|output_format=s" => \$output_format,
			    "d|debug" => \$dbg,
			    "man" => \$man,
			    "help|?" => \$help) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;

system ("mkdir -p $temp_dir") if ($temp_dir);

# COLLECT USER INPUT

my $user_params;

if( -e $input_file ) { $user_params = Config::IniFiles->new( -file =>  glob($input_file) ); } else { confess ("$err Cannot open input file $input_file $!")} 
confess  ("$err Cannot read user parameter file. Exiting.")     if (!defined ($user_params));

# Get sequence
my $sequence = glob($user_params->val('main', 'input')) || confess ("No input specified. Exiting");

my @sequence; push (@sequence, $sequence);

# sequence_file holds sequence information and resides in intermediate work directory
my $sequence_file=$temp_dir."/".fileparse($input_file); 

cluck ("$warn Called interpretSeqPP($sequence_file,\"\",60,17,5000,80 @sequence)");
my ($LokWrt,$msg,$lenTmp)=
    RG::PP::interpretSeqPP($sequence_file,"",60,17,5000,80,@sequence);

croak ($msg) if ($LokWrt!=1); # NOTE: interepretSeqPP returns 1 on normal completion

# PRINT OUT JOB ENV
if ($dbg){
    cluck "temp_dir=$temp_dir";
}

# RUN MAKEFILE
# FORMAT RESULTS
# CONVERT TO XML
my $command = "make ";
$command .= "OUTPUTFILE=".glob($output_file);
if ($output_format =~ /html/){  
    $command.=".html ";# if ($output_file !~ /\.html$/); 
    $make_file=$root_dir."/makepphtml.mk"; 
}else { 
    $command .=" "; 
}
$command .= "INFILE=".glob($sequence_file)." ";
$command .= "-f ".glob($make_file)." " if ($make_file);
$command .= "MAIN_PIPELINE=$main_make_file "; 
$command .= "TEMPDIR=$temp_dir " if ($temp_dir);
$command .= "JOBID=$proc_name " if ($proc_name);
$command .= "-n " if ($dry_run);
cluck ($command) if ($dbg);

system ($command);


# CLEAN UP PROCESS

exit(0);

__END__
=head1 predictprotein -

Protein sequence analysis suite

=head1 SYNOPSIS

predictprotein [options] [file ...]

=head1 INPUT

-input_file: parameter and input sequence

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits. 

=item B<-man>

This documentation page

=item B<-verbose>

Prints all debug information.

=back

=head1 DESCRIPTION

B<This program> runs a set of protein sequnce analysis methods

=head1 EXAMPLE

C<predictprotein -i /usr/share/predictprotein/example/MT4_HUMAN.in>

=head2 INPUT FILE

return no alignment

run profsec

run mdisorder_fast

run profacc

run isis

run disis

ret html

# default: single protein sequence resfilename=d7827c495a4ee0bf5f465a0cf775591c0ac8c24c

MSAQISDSIEEKRGFFTRWFMSTNHKDIGVLYLF

=head1 ENVIRONMENT

=over

=item PREDICTPROTEINCONF

Location of snapfunrc configuration file to use, overriding other configuration files                               


