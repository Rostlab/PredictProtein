#!/usr/pub/bin/perl5 -w
##!/usr/pub/bin/perl
##!/usr/local/bin/perl
#
# Author: Kay Hofmann (khofmann@isrec-sun1.unil.ch) December 1994
#
# This program scans a protein database with a collection of regular 
# expression patterns (like the one generated by prosite_convert).
# For each of the patterns, it reports the number of total hits and
# the number of sequences with hits.
# Supported database formats are EMBL/Swissprot and FASTA format
#
# The call syntax is:
#        prosite_statisctics patternfile sequencefile outfile
# 
#


##################################################################
# get sequence in any format and put it into Seq, SeqID and SeqDE
##################################################################

sub getseq {
    if    ($format eq "FASTA") {
      &getfasta;
      $Seq   = $fastabuffer;
      $SeqID = $FastaID;
      $SeqDE = $FastaDE;
    }
    elsif ($format eq "EMBL")  {
      &getembl;
      $Seq   = $emblbuffer;
      $SeqID = $EmblID;
      $SeqDE = $EmblDE;
    }
    else                       {
      &getgcg;
      $Seq   = $gcgbuffer;
      $SeqID = $gcgid;
      $SeqDE = $gcgde;
    }
  }
  
###################################################################
# read Pearson/FASTA format sequence (not to be called externally) 
###################################################################
  
  sub getfasta {
    $fastabuffer="";
    $FastaID="";
    $FastaDE="";
    $line="";
    until (($fastaline =~ /^\>/) || eof(SEQFILE)) {$fastaline=<SEQFILE>};
    if ($fastaline=~/^\>(\S+)\s(.*)$/) {
      $FastaID=$1;
      $FastaDE=$2;
    }
    until (($line =~ /^\>/) || eof(SEQFILE)) {
      $line=<SEQFILE>;
      if (!($line =~ /^\>/)) {$fastabuffer .= $line}
    }
    if ($line =~ /^\>/) {$fastaline=$line}
    else {$fastaline=""};
    $fastabuffer =~ tr/a-z/A-Z/;
    $fastabuffer =~ s/[^A-Z]//g;
  }

###################################################################
# read EMBL/Swissprot format sequence (not to be called externally) 
###################################################################
    
  sub getembl {
    $emblbuffer="";
    $EmblID="";
    $EmblDE="";
    $line="";
    until (($line =~ /^ID\s/) || eof(SEQFILE)) {$line=<SEQFILE>};
    if ($line=~/^ID\s+(\w+).*$/)          {$EmblID=$1;}
    until (($line =~ /^SQ\s/) || eof(SEQFILE)) {
      $line=<SEQFILE>;
      if ($line =~ /^DE\s+(.*)/) {
        if($EmblDE) {$EmblDE.=" "};
	$EmblDE .= $1
      }
    }
    if ($line =~ /^SQ\s/) {
      until (($line =~ /^\/\//) || eof(SEQFILE)) {
        $line=<SEQFILE>;
        if   (!($line =~ /^\/\//)) {$emblbuffer .= $line}
      }
    }
    $emblbuffer =~ tr/a-z/A-Z/;
    $emblbuffer =~ s/[^A-Z]//g;
  }
    
###################################################################
# read GCG format sequence (not to be called externally) 
###################################################################
  
  sub getgcg {
    $gcgbuffer="";
    $gcgid="";
    $line="";
    until (($line =~ /\.\./) || eof(SEQFILE)) {$line=<SEQFILE>};
    if ($line=~/^(\w*).*\.\./)                {$gcgid=$1;}
    until (eof(SEQFILE)) {
      $line=<SEQFILE>;
      $gcgbuffer .= $line
    }
    $gcgbuffer =~ tr/a-z/A-Z/;
    $gcgbuffer =~ s/[^A-Z]//g;
  }
    
# --------- Program starts here -----------------------------------

###################################################################
# test command line arguments and open files:
###################################################################
  

  if($#ARGV!=2)        {die "SYNTAX: prosite_statistics patternfile sequencefile outfile\n"};
  unless (-T $ARGV[0]) {die "$ARGV[0] no valid input file\n"};  
  unless (-T $ARGV[1]) {die "$ARGV[1] no valid input file\n"};  
  open(PATFILE,"$ARGV[0]")   || die "can't open $ARGV[0]: $!\n"; 
  open(SEQFILE,"$ARGV[1]")   || die "can't open $ARGV[1]: $!\n";
  open(OUTFILE,">$ARGV[2]")  || die "can't open $ARGV[2]: $!\n";


###################################################################
# determine sequence file format
###################################################################

  $line=<SEQFILE>;
  if    ($line =~ /^\>/)        {$format="FASTA"}
  elsif ($line =~ /^ID\s/)      {$format="EMBL"}
  else  {
    while (!($line =~ /\.\./) && ($line=<SEQFILE>)) {}
    if ($line=~/\.\./)      {$format="GCG"}
    else {die "Sequence format not recognized\n"}
  }
  close(SEQFILE);
  open(SEQFILE,"$ARGV[1]")   || die "can't reopen $ARGV[1]: $!\n";

###################################################################
# read all patterns from file
###################################################################

  $ct=0;
  while (<PATFILE>) {
    $ct=$ct+1;
    ($pattern[$ct], $patID[$ct], $patAC[$ct], $patDO[$ct], 
     $patSK[$ct],   $patDE[$ct]) = split(' ',$_,6);
    if ($patDE[$ct] =~ /^\"(.*)\"$/)     {$patDE[$ct]=$1};
    $matchtotcount[$i]=0;  #number of total matches of this pattern
    $matchseqcount[$i]=0;  #number of sequences with matches of this pattern
  }
  $maxpat=$ct;
  print "$maxpat patterns read\n";  
  close(PATFILE);

###################################################################
# scan all patterns for each sequence found in file
###################################################################

  ########## for each sequence, scan all patterns and increase counters
  do {
    &getseq;
    if ($Seq) {
      $numseq = $numseq + 1;
      $numres = $numres + length($Seq);
      print "$SeqID\n";
      for ($i=1; ($i<=$maxpat); $i++) {
	$oldcount=$matchtotcount[$i];
	while ($Seq =~ /$pattern[$i]/g) {$matchtotcount[$i]++;}
	if ($matchtotcount[$i] > $oldcount) {$matchseqcount[$i]++}
      }
    }
  } until ($Seq eq "");
  close(SEQFILE);
  
  ##### finally, report the results

  print OUTFILE "# Database contains $numseq sequences with $numres residues\n";
  print OUTFILE "# PROSITE_ID   , total matches , matching SEQs, per 1000 res.\n";
  for ($i=1; ($i<=$maxpat); $i++) {
    $field1=$patAC[$i];
    while (length($field1)<15) {$field1 .=' '}
    $field2=$matchtotcount[$i];
    if ($field2=='') {$field2='0'}
    while (length($field2)<15) {$field2 .=' '}
    $field3=$matchseqcount[$i];
    if ($field3=='') {$field3='0'}
    while (length($field3)<15) {$field3 .=' '}
    $field4=$matchtotcount[$i]*1000/$numres;
    if ($field4=='') {$field4='0'}
    $field4=sprintf("%8.4f",$field4);
    while (length($field4)<15) {$field4 .=' '}
    print OUTFILE "$field1,$field2,$field3,$field4\n"; 
  }
  close(OUTFILE);
