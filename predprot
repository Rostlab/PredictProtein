#!/usr/bin/perl -w
use warnings;
use strict;
use Data::Dumper;
use Carp qw(cluck croak confess longmess);
use Getopt::Long;
use File::Copy;
use File::Temp;
use File::Basename;
use Pod::Usage;
use Config::IniFiles;
use Bio::Seq;
use Bio::SeqIO;

$Carp::Verbose = 1; 

my $warn = "---";
my $err = "***";

# SYSTEM CONFIGURATION RETRIEVAL
our $config;
my ($pp_rootdir,$librg_utils_perl);
BEGIN {
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
    $ENV{PATH} = "/bin:/usr/bin";
    my ( $defaultconfig, $etcconfig );
    if( -e "__pkgdatadir__/predictproteinrc.default" ) { $defaultconfig = Config::IniFiles->new( -file => "__pkgdatadir__/predictproteinrc.default" ); }
    if( -e "__sysconfdir__/predictproteinrc" ) { $etcconfig = Config::IniFiles->new( -file => "__sysconfdir__/predictproteinrc", -import => $defaultconfig ); } else { $etcconfig = $defaultconfig; }
    if( ( $ENV{PREDICTPROTEINCONF} && -e "$ENV{PREDICTPROTEINCONF}" ) || -e "$ENV{HOME}/.predictproteinrc" ) { $config = Config::IniFiles->new( -file => $ENV{PREDICTPROTEINCONF} || "$ENV{HOME}/.predictproteinrc", -import => $etcconfig ); } else { $config = $etcconfig; }
}

# NOTE: all configuration can be overridden by command line options
$pp_rootdir  = glob($config->val('predictprotein', 'predictprotein_utildir')).'/';
$librg_utils_perl = glob($config->val('predictprotein', 'librg_utils_perl')).'/' || '/usr/share/librg-utils-perl/';
my $db_blast_train = glob($config->val('blast', 'uniref'));
my $db_blast_final = glob($config->val('blast', 'uniref90'));
my $prof_app_root = glob($config->val('support_apps', 'prof'));
my $proftmb_app_root = glob($config->val('support_apps', 'proftmb'));
my $root_dir = $pp_rootdir || "__pkgdatadir__";
my $make_file = $root_dir."/MakefilePP.mk";

my $output_format = "text";
my $work_dir;

# COMMAND LINE OPTIONS
my($help, $man, $dbg, $dry_run, $prot_name, $input_file, @method, $output_dir, $seqfile, $sequence_in, @target, $version);

my $num_cpus = 1;
my $blast_processors = 1;

if (@ARGV < 1){ die "Usage: $0 [OPTIONS]\n";}

my $result = GetOptions (
			    "blast-processors=i" => \$blast_processors,
          "i|input-file=s" => \$input_file,
			    "o|output-dir=s" => \$output_dir,
			    "m|make-file=s" =>\$make_file,
			    "p|prot-name=s" =>\$prot_name,
			    "s|seq|sequence=s" =>\$sequence_in,
          'seqfile=s' => \$seqfile,
			    "c|num-cpus=i" =>\$num_cpus,
			    "w|work-dir=s" => \$work_dir,
			    "n|dryrun" => \$dry_run,
			    "f|output-format=s" => \$output_format,
			    "d|debug!" => \$dbg,
			    "v|version" => \$version,
			    "man" => \$man,
			    "help|?" => \$help,
          #
          'method=s@' => \@method,
          'target=s@' => \@target
) or pod2usage(2);

pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;
if ($version){
    print STDERR qq|This is PredictProtein version __pkgver__

Copyright 1992-2010, Rostlab

Please see COPYING file for license information

Complete documentation for PredictProtein,  should be found on
this system using "man predprot" or at http://www.predictprotein.org/.

|;
    exit (0);
}

my( $makemethod, $maketarget ) = _get_makemethod( \@method );

if( !$output_dir ){ die("Error: no output directory given, use --output-dir option".( $dbg ? '' : "\n" ) ); }
$output_dir = glob($output_dir);
system( 'mkdir', '-p', $output_dir ) && die( "could not mkdir '$output_dir': ".($? >> 8 ));

if(! $prot_name){ $prot_name="query"; }
if( $prot_name =~ /[^[:alnum:] -._]/o ){ die("Error: invalid protein name, please use only [[:alnum:] -._]".( $dbg ? '' : "\n" )); }

if( !@target ){ @target = ( 'all' ); }

if( ! $work_dir ){ $work_dir = File::Temp::tempdir( CLEANUP => !$dbg ); }
else { $work_dir = glob($work_dir); system ( "mkdir", '-p', $work_dir ) && die( "could not mkdir '$work_dir': ".($? >> 8) ); }

if( $seqfile )
{
  my $in = Bio::SeqIO->new( ( $seqfile eq '-' ? ( -fh => \*STDIN ) : ( -file => $seqfile ) ), -format => 'Fasta' );
  my $seq = $in->next_seq();
  $sequence_in = $seq->seq();
}


# COLLECT USER INPUT
if( $input_file )
{
  my $user_params = Config::IniFiles->new( -file =>  glob($input_file) );
  if( !defined ($user_params) ){ confess("$err Cannot read user parameter file. Exiting."); }
}

# Get sequence
my $sequence_as_string = $sequence_in || die("Error: no input sequence".( $dbg ? '' : "\n" ));

# work_seq_file holds sequence information and resides in intermediate work directory - this is written by RG::PP::interpretSeqPP
my $work_seq_file = "$work_dir/$prot_name.in";

if( ! -e $work_seq_file )
{
  my $seqobj = Bio::Seq->new( -display_id => $prot_name, -seq => $sequence_as_string);
  my $seqout= Bio::SeqIO->new( -format => 'Fasta', -file => ">$work_seq_file" );
  $seqout->write_seq($seqobj);
}

# get number of processors on this host
#my @num_cpus=();
#if (!($num_cpus) && -e '/proc/cpuinfo'){
#     @num_cpus=`grep processor /proc/cpuinfo`;
#     $num_cpus = scalar(@num_cpus);
#}

# PRINT OUT JOB ENV
if ($dbg){ cluck "work_dir=$work_dir"; }





# RUN MAKEFILE
my @cmd = ();
push (@cmd,"make");
push (@cmd,"INFILE=$work_seq_file");
if( $work_dir ){ push (@cmd,"WORKDIR=$work_dir/"); }
push (@cmd,"JOBID=".$prot_name);
push (@cmd, "-n") if ($dry_run);
push (@cmd, "-j");
push (@cmd, $num_cpus);
push (@cmd, "BLASTCORES=".$blast_processors);
push (@cmd, "LIBRGUTILS=".$librg_utils_perl);
push (@cmd, "PPROOT=".$pp_rootdir);
push (@cmd, "PROFROOT=".$prof_app_root);
push (@cmd, "PROFTMBROOT=".$proftmb_app_root);
push (@cmd, @$makemethod );
if( $dbg ){ push (@cmd, "DEBUG=".$dbg); }

if ($make_file){
    push (@cmd,"-f");
    push (@cmd,glob($make_file));
}

# target
my @cmd_all = ( @cmd, @target );
if( !@target || $target[0] ne 'all' ){ push @cmd_all, @$maketarget; } # all is `all', no need to specify them individually

if ($dbg) { cluck("@cmd_all"); }
system (@cmd_all) && die( "@cmd_all failed: ".($? >> 8 ) );

my @cmd_install = ( @cmd, "DESTDIR=$output_dir", 'install' );

if ($dbg) { cluck("@cmd_install"); }
system( @cmd_install ) && die( "@cmd_install DESTDIR=$output_dir install failed: ".( $? >> 8 ) );

if( $dbg ){ warn( "prediction complete, results are in $output_dir" ); }

exit(0);



# method - translate and pass --method=asp,ws=3,... --method=... method control parameters to make file
# idea: translate control params simply like this: --method=MNAME,CTRLP1=CTRLVAL1, -> NMAMECTRL=--CTRLP1=CTRLVAL1
# Also return all methods as targets.
sub               _get_makemethod
{
  my( $__method ) = @_;
  my $makemethod = [];
  my $maketarget = [];

  foreach my $method_cm ( @$__method )
  {
    # split each string in two parts:method and res 
    my ($meth1, $rest)= split /,/o, $method_cm, 2; 

    push @$maketarget, $meth1;
  
    # split rest after and save in an array
    my @tmp_hash; if( $rest ){ @tmp_hash = split /,/o, $rest; }
  
    #look for the crtl and res elements for each method
    my @tmp_crl = grep( !/^res_/o, @tmp_hash );
    my @tmp_res = grep( /^res_/o, @tmp_hash );

    if( @tmp_res ){ warn( "Warning: `res_'-type parameters were given ('@tmp_res') - these are ignored by this program\n" ); }

    if( @tmp_crl )
    {
      # Certain methods like profbval do not accept Getopt::Long-style cmd line parameters. That's bad. We can not pass parameters to such methods because we do not want to program special cases for them.
      # The long term solution is to make these methods accept Getopt::Long params.
      if(
        $meth1 eq 'prof' ||
        $meth1 eq 'profbval' ||
        $meth1 eq 'norsnet'
      ){ die("Error: this interface does not support passing control parameters to $meth1 because of ${meth1}'s primitive command line interface.".( $dbg ? '' : "\n" )); }
    }
  
    #store the results from each crt and res elemnt as one hash
    push @$makemethod, uc( $meth1 ).'CTRL="'.join(' ', map {
      my $ctrlpair = $_;
      if( $ctrlpair =~ /^-/o ){ confess( "Error: control parameter with leading `-': '$ctrlpair'" ); } "--$_";
    } @tmp_crl ).'"';
  }

  return( $makemethod, $maketarget );
}

__END__

=head1 NAME

predprot - Protein sequence analysis suite

=head1 SYNOPSIS

predprot [options] [file ...]

=head1 INPUT

--input-file: parameter and input sequence - NOT IMPLEMENTED

=head1 OPTIONS

=over 8

=item B<--blast-processors>

Number of processors to use, default = 1

=item B<-i|input>

path to input file

=item B<-s|sequence>

one letter amino acid sequence input

=item B<-o|output-dir>

Final location of outputfiles

=item B<-c|num-cpus>

Number of threads to use (default is one)

=item B<-d|debug>

A lot of verbiage

=item B<-v|version>

Print package version

=item B<-n|dryrun>

Do not exectute, just shows what is about to be run.

=item B<-help>

Print a brief help message and exits.

=item B<-man>

This documentation page

=item B<--debug>

Prints all debug information.

=item B<-w|--work-dir>

Working directory. Optional.

=back

=head1 DESCRIPTION

B<This program> runs a set of protein sequnce analysis methods

=head1 EXAMPLE

C<predprot -i __pkgdatadir__/example/tquick.in -d -o /tmp/pp/tquick.out/>

=head1 ENVIRONMENT

=over

=item PREDICTPROTEINCONF

Location of predictproteinrc configuration file to use, overriding other configuration files

=back

=head1 FILES

=over

=item F<__pkgdatadir__/predictproteinrc.default>

Default configuration file. See this file for a description of the parameters.

=item F<__sysconfdir__/predictproteinrc>

System configuration file overriding values in F<__pkgdatadir__/predictproteinrc.default>

=back

=head1 AUTHOR

Burkhard Rost, Antoine de Daruvar, Jinfeng Liu, Guy Yachdav, Laszlo Kajan, Markus Schmidberger

=head1 SEE ALSO

ppqsub(1),  ppc_store(1),  ppc_fetch(1)

=cut

# vim:et:ts=2:ai:
