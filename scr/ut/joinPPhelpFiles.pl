#!/usr/local/bin/perl -w
##!/usr/pub/bin/perl -w
##!/usr/sbin/perl -w
#
$scrName=$0;$scrName=~s/^.*\/|\.pl//g;
$scrGoal="concatenates all the PP help files into one big help file\n".
    "     \t to be saved as text manually...";
#  
# 
#------------------------------------------------------------------------------#
#	Copyright				        	1999	       #
#	Burkhard Rost		rost@EMBL-Heidelberg.DE			       #
#	Wilckensstr. 15		http://www.embl-heidelberg.de/~rost/	       #
#	D-69120 Heidelberg						       #
#				version 0.1   	Oct,    	1998	       #
#------------------------------------------------------------------------------#
#
#    ------------------------------
#    action(s)
#    ------------------------------
#    
#    Once = done at startup:
#    * checks space quota, frees space
#    * detects dead requests
#    * writes status report to WWW  (wwwStatusPP.pl)
#    
#    Loop = done in infinite loop (while flag file $envPP{'file_scanFlag'} exists):
#    * scans the file(s) generated by:
#      (a) procmail                 (procmailPP.pl)
#      (b) cgi-script from WWW      (submitPP.pl)
#      see 'assumptions'
#      see 'file format'
#    * runs the predictions         (predictPP.pl)
#    * sends mail to user           ()
#    *        ()
#    *        ()
#    
#    ------------------------------
#    text markers
#    ------------------------------
#
#  - 'xx'         : to do, error break
#  - 'yy'         : to do at later stage
#  - 'HARD_CODED' : explicit names
#  - 'br date'    : changed on date
#  - 'hack'       : some hack 
#    
#    ------------------------------
#    assumptions
#    ------------------------------
#
#    The following assumption are made:
#    * help files in dir      'dir_www_doc'."doc/"
#    * filename starts with   'help'
#    * ignores files with     'help_<hello|entry>'
#    
#    
#------------------------------------------------------------------------------#

$[ =1 ;				# start counting at 1
				# --------------------------------------------------
				# initialise environment parameters
				# --------------------------------------------------
($Lok,$msg)=
    &ini();
				# ******************************
				# *** error in local env
die ("*** ERROR $scrName: failed during ini\n".
     $msg."\n")                  if (! $Lok);
				# ******************************


				# ------------------------------
				# determine files
$dir=$envPP{"dir_www_doc"}."doc";
@tmp=&fileLsAllTxt($dir);

				# take only those in local dir
$fileToc=0;

foreach $tmp (@tmp) {
    next if ($tmp=~/$dir..*\//);
    next if (! -e $tmp);
    next if ($tmp!~/help/);	# skip non-help files

    next if ($tmp=~/help[_\-]?(hello|entry)/i);

    if ($tmp=~/toc/i) {		# is TOC (dont take here since used as first file...)
	$fileToc=$tmp;		# 
	next; }

    push(@file,$tmp);
}
$#tmp=0;			# slim-is-in

				# sort
@file=sort (@file);

				# --------------------------------------------------
				# loop over all help files
				# --------------------------------------------------
open($fhout,">".$fileOut) || 
    do { print "*** ERROR $scrName: failed opening out=$fileOut!\n";
	 print "***       -> written onto STDOUT!\n";
	 $fhout="STDOUT"; };
				# write HTML header
print $fhout "<HTML><HEAD><TITLE>PP help</TITLE></HEAD>\n","<BODY>\n"
    if ($fhout ne "STDOUT");
    
@file=($fileToc,@file)          if ($fileToc);

				# loop
foreach $file (@file) {
    print "--- $scrName tries to read $file\n" if ($Ldebug);
				# open help file
    open($fhin,$file) ||
	do { print "*** ERROR $scrName: failed opening in=$file! (will be skipped)\n";
	     next; };
    $Lwrt=$Lskip=$LskipSubtoc=0;
    while (<$fhin>) {
	$line=$_;
				# finish when body ended
	last if ($line=~/<\/BODY>/ ||
		 $line=~/<A NAME=\"bottom\">/i ||
		 $line=~/bottom links/);

	if    (! $Lwrt && $line=~/<BODY>/) {
	    $Lwrt=1; 
	    next; }
	next if (! $Lwrt);

				# skip 'bottom' 'top' stuff
	if ($line=~/A NAME=\"top\"/i) {
	    $Lskip=1; }
	if ($Lskip && $line=~/<\/A>/ && $line!~/<A HREF/) {
	    $Lskip=0;
	    next; }
	next if ($Lskip);

				# skip subtoc
	if ($file !~/toc/ && $line=~/<DIV.*subtoc.*>/) {
	    $LskipSubtoc=1; }
	if ($LskipSubtoc && $line=~/<\/DIV>/i){
	    $LskipSubtoc=0;
	    next; }
	next if ($LskipSubtoc);

	print $fhout $line; 
    }
    close($fhin);
}
				# finish new file
print $fhout "</BODY>\n"        if ($fhout ne "STDOUT");
close($fhout)                   if ($fhout ne "STDOUT");

print "--- output=$fileOut\n"   if (-e $fileOut);
exit(1);


#===============================================================================
sub ini {
    $[ =1 ;
#-------------------------------------------------------------------------------
#   ini                         gets the parameters from env, and checks
#-------------------------------------------------------------------------------
				# ------------------------------
				# get the name of this file
    $scrName=$0;$scrName=~s/^.*\/|\.pl//g;

				# ------------------------------
				# defaults
				# ------------------------------
    %par=(
	  'dirHelpDoc', "/home/$ENV{USER}/public_html/",
	  '', "",
	  );
    @kwd=sort (keys %par);
				# ------------------------------
    if ($#ARGV<1){		# help
				# ------------------------------
	print  "goal: $scrGoal\n";
	print  "use:  '$scrName name_of_output_file'\n";
	print  "opt:  \n";
				#      'keyword'   'value'    'description'
#	printf "%5s %-15s=%-20s %-s\n","","",   "x", "";
#	printf "%5s %-15s %-20s %-s\n","","",   "no value","";
	printf "%5s %-15s %-20s %-s\n","","dbg",   "no value","debug mode";

	if (defined %par && $#kwd > 0){
	    $tmp= sprintf("%5s %-15s  %-20s %-s\n","","-" x 15 ,"-" x 20,"-" x 30);
	    $tmp.=sprintf("%5s %-15s  %-20s %-s\n","","other:","default settings: "," ");
	    $tmp2="";
	    foreach $kwd (@kwd){
		next if (! defined $par{"$kwd"} || length($par{"$kwd"})<1 );
		if    ($par{"$kwd"}=~/^\d+$/){
		    $tmp2.=sprintf("%5s %-15s= %10d %9s %-s\n","",$kwd,$par{"$kwd"}," ","(def)");}
		elsif ($par{"$kwd"}=~/^[0-9\.]+$/){
		    $tmp2.=sprintf("%5s %-15s= %10.3f %9s %-s\n","",$kwd,$par{"$kwd"}," ","(def)");}
		else {
		    $tmp2.=sprintf("%5s %-15s= %-20s %-s\n","",$kwd,$par{"$kwd"},"(def)");} 
	    } 
	    print $tmp, $tmp2       if (length($tmp2)>1);
	}
	exit(0);}
				# initialise variables

    $fhin="FHIN";$fhout="FHOUT"; $Ldebug=0;

				# ------------------------------
				# read command line
				# ------------------------------
    $fileOut=$ARGV[1];
    foreach $arg (@ARGV){
	next if ($arg eq $ARGV[1]);
	if    ($arg=~/^de?bu?g$/i)            { $Ldebug=1;}
#	elsif ($arg=~/^=(.*)$/){ $=$1;}
	else {
	    $Lok=0; 
	    if (defined %par && $#kwd>0) { 
		foreach $kwd (@kwd){ 
		    if ($arg =~ /^$kwd=(.+)$/){$Lok=1;$par{"$kwd"}=$1;
					       last;}}}
	    if (! $Lok){ print "*** wrong command line arg '$arg'\n";
			 exit;}}}
    
				# --------------------------------------------------
				# include envPP package as define in $PPENV or default
				# --------------------------------------------------
    if ($ENV{'PPENV'}) {
	$env_pack = $ENV{'PPENV'}; }
    else {				# this is used by the automatic version!
	$env_pack = "/home/$ENV{USER}/server/scr/envPP.pm"; } # HARD CODDED, HARD_CODDED

    $Lok=
	require $env_pack;
                    		# *** error in require env
    return(0,"*** ERROR $scrName: require env_pack=".$env_pack."\n".
	   "*** err=9101")      if (! $Lok);

				# ------------------------------
				# read local environment var
				# ------------------------------
    foreach $des ("dir_www_doc",
				# log files
		  "file_crontabLog",
		  ){
	$envPP{$des}=&envPP'getLocal($des);                      # e.e'
				# *** error in local env
	return(0,"*** err=9102\n"."failed to get envPP{$des} from env_pack '$env_pack'\n") 
	    if (! defined $envPP{$des});
    }

				# ------------------------------
				# corrections to environment
				# ------------------------------

				# ------------------------------
				# get the date
    $Date=&sysDate();
    
    return(1,"ok");
}				# end of ini

#===============================================================================
sub errSbr    {local($txtInLoc,$sbrNameLocy) = @_ ;
#-------------------------------------------------------------------------------
#   errSbr                      simply writes '*** ERROR $sbrName: $txtInLoc'
#-------------------------------------------------------------------------------
	       $sbrNameLocy=$sbrName if (! defined $sbrNameLocy);
	       $txtInLoc.="\n";
	       $txtInLoc=~s/\n\n+/\n/g;
	       return(0,"*** ERROR $sbrNameLocy: $txtInLoc");
}				# end of errSbr

#===============================================================================
sub errSbrMsg {local($txtInLoc,$msgInLoc,$sbrNameLocy) = @_ ;
#-------------------------------------------------------------------------------
#   errSbrMsg                   simply writes '*** ERROR $sbrName: $txtInLoc\n'.$msg
#-------------------------------------------------------------------------------
	       $sbrNameLocy=$sbrName if (! defined $sbrNameLocy);
	       $txtInLoc.="\n";
	       $txtInLoc=~s/\n\n+/\n/g;
	       $msgInLoc.="\n";
	       $msgInLoc=~s/\n\n+/\n/g;
	       return(0,"*** ERROR $sbrNameLocy: $txtInLoc".$msgInLoc);
}				# end of errSbrMsg

#===============================================================================
sub errScrMsg {local($txtInLoc,$msgInLoc,$scrNameLocy) = @_ ;
#-------------------------------------------------------------------------------
#   errScrMsg                   writes message and EXIT!!
#-------------------------------------------------------------------------------
	       $scrNameLocy=$scrName if (! defined $scrNameLocy);
	       $txtInLoc.="\n";
	       $txtInLoc=~s/\n\n+/\n/g;
	       if (defined $msgInLoc) {
		   $msgInLoc.="\n";
		   $msgInLoc=~s/\n\n+/\n/g;}
	       else {
		   $msgInLoc="";}
	       print "*** ERROR $scrNameLocy: $txtInLoc".$msgInLoc;
	       exit; 
}				# end of errScrMsg

#==========================================================================================
sub fileLsAllTxt {
    local($dirLoc) = @_ ;local($sbrName,$fhinLoc,@tmp);
#--------------------------------------------------------------------------------
#   fileLsAllTxt                will return all text files in dirLoc (and
#                               subdirectories therof)
#       in:                     dirLoc (directory)
#       out:                    @files
#--------------------------------------------------------------------------------
    $sbrName="fileLsAllTxt";$fhinLoc="FHIN"."$sbrName";
    if (! -d $dirLoc){		# directory empty
	return(0);}
    open($fhinLoc,"find $dirLoc -print |");
    while (<$fhinLoc>){$line=$_; $line=~s/\s//g;
		       if (-T $line && ($line!~/\~$/)){
			   $tmp=$line;$tmp=~s/$dirLoc//g;$tmp=~s/^\///g;
			   next if ($tmp=~/\#|\~$/); # skip temporary
#			   next if ($tmp=~/\//);
			   push(@tmp,$line);}}close($fhinLoc);
    return(@tmp);
}				# end of fileLsAllTxt

#===============================================================================
sub sysDate {
#    local($sbrName,$fhinLoc,$tmp,$Lok);
    $[ =1 ;
#-------------------------------------------------------------------------------
#   sysDate                     returns $Date
#       out:                    $Date (May 30, 1998 59:39:03)
#-------------------------------------------------------------------------------

    @tmp=(			# HARD_CODED
	  "/home/rost/perl/",
	  "/home/rost/pub/perl/"
	  );
    $exe_ctime="ctime.pl";	# local ctime library

    $Lok=0;
				# ------------------------------
				# get function
    if (defined &localtime) {
				# use system standard
	$Lok=1	                if (defined &ctime && &ctime);
				# use local library
	$Lok=1                  if (! $Lok && -e $exe_ctime);

	if (! $Lok) {		# search for it
	    foreach $tmp (@tmp){
		$exe_tmp=$tmp.$exe_ctime;
		if (-e $tmp){
		    $Lok=
			require("$exe_tmp");
		    last;}}}
				# ------------------------------
				# found one: use it
	if ($Lok && 
	    defined &ctime && &ctime && defined &localtime && &localtime){
#       	$date is e.g.:		Oct:14:13:06:47:1993
#       	@Date is e.g.:		Oct1413:06:471993
#        	&ctime(time) is e.g.:	Thu Oct 14 13:06:47 1993
	    @Date = split(' ',&ctime(time)) ; shift (@Date) ; 
	    $Date="$Date[2] $Date[3], $Date[$#Date]  $Date[4]";
	    return($Date);} }
				# ------------------------------
	 			# found none: take system
    if (! $Lok) {
	$localtime=`date`;
	@Date=split(/\s+/,$localtime);
	$Date="$Date[2] $Date[3], $Date[$#Date] $Date[4]"; }
    return($Date);
}				# end of sysDate


#================================================================================ #
#                                                                                 #
#-------------------------------------------------------------------------------- #
# Predict Protein - a secondary structure prediction and sequence analysis system #
# Copyright (C) <2004> CUBIC, Columbia University                                 #
#                                                                                 #
# Burkhard Rost         rost@columbia.edu                                         #
# http://cubic.bioc.columbia.edu/~rost/                                           #
# Jinfeng Liu             liu@cubic.bioc.columbia.edu                             #
# Guy Yachdav         yachdav@cubic.bioc.columbia.edu                             #
#                                                                                 #
# This program is free software; you can redistribute it and/or modify it under   #
# the terms of the GNU General Public License as published by the Free Software   #
# Foundation; either version 2 of the License, or (at your option)                #
# any later version.                                                              #
#                                                                                 #
# This program is distributed in the hope that it will be useful,                 #
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  #
# or FITNESS FOR A PARTICULAR PURPOSE.                                            #
# See the GNU General Public License for more details.                            #
#                                                                                 #
# You should have received a copy of the GNU General Public License along with    #
# this program; if not, write to the Free Software Foundation, Inc.,              #
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA                         #
#                                                                                 #
# Contact Information:                                                            #
#                                                                                 #
# predict_help@columbia.edu                                                       #
#                                                                                 #
# CUBIC   Columbia University                                                     #
# Department of Biochemistry & Molecular Biophysics                               #
# 630 West, 168 Street, BB217                                                     #
# New York, N.Y. 10032 USA                                                        #
# Tel +1-212-305 4018 / Fax +1-212-305 7932                                       #
#================================================================================ #
